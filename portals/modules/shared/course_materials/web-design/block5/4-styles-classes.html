<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manipulating Styles & Classes in JavaScript - COMPLETE</title>
    <style>
        /* minimal styling for readability - preserves all content */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #f5f7fb;
            font-family: 'Segoe UI', Roboto, system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #1e2b3a;
            padding: 2rem 1.2rem;
        }

        .document-wrapper {
            max-width: 1300px;
            margin: 0 auto;
            background: white;
            border-radius: 2rem;
            box-shadow: 0 20px 40px -15px #1f3a4b;
            padding: 2.5rem 2rem;
        }

        h1,
        h2,
        h3,
        h4 {
            color: #215c7a;
            margin-top: 2.2rem;
            margin-bottom: 1rem;
            font-weight: 650;
            line-height: 1.2;
        }

        h1 {
            font-size: 2.6rem;
            border-left: 10px solid #c9826b;
            padding-left: 1.4rem;
            margin-top: 0.5rem;
            background: linear-gradient(145deg, #1f5f7e, #bf6f5a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            font-size: 2rem;
            border-bottom: 3px solid #cf8a72;
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.7rem;
            margin-top: 2rem;
        }

        h4 {
            font-size: 1.3rem;
            margin-bottom: 0.5rem;
        }

        p,
        li,
        .block {
            margin-bottom: 1rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.8rem 0;
            border-radius: 1.2rem;
            overflow: hidden;
            box-shadow: 0 6px 18px rgba(20, 65, 95, 0.1);
        }

        th {
            background: #2c6e8f;
            color: white;
            font-weight: 600;
            padding: 0.9rem 0.8rem;
            text-align: left;
        }

        td {
            padding: 0.8rem;
            border-bottom: 1px solid #c3d9ea;
            background: #f9fcff;
        }

        code,
        pre {
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            background: #eef4f9;
            border-radius: 8px;
            font-size: 0.95rem;
        }

        code {
            padding: 0.2rem 0.4rem;
        }

        pre {
            padding: 1.2rem;
            overflow-x: auto;
            border: 1px solid #b6cfdf;
            margin: 1.5rem 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        ul,
        ol {
            padding-left: 1.8rem;
            margin: 1rem 0;
        }

        li {
            margin: 0.4rem 0;
        }

        .table-of-contents {
            background: #e3f0fa;
            padding: 1.8rem 2rem;
            border-radius: 2rem;
            margin: 2rem 0;
        }

        .table-of-contents ul {
            columns: 2 220px;
            list-style: none;
            padding-left: 0;
        }

        .table-of-contents li {
            margin: 0.4rem 0;
        }

        .table-of-contents a {
            text-decoration: none;
            color: #1f5f7e;
            font-weight: 500;
            display: inline-block;
            padding: 0.2rem 0;
            border-bottom: 1px solid transparent;
        }

        .table-of-contents a:hover {
            border-bottom-color: #bf6f5a;
        }

        hr {
            border: none;
            height: 3px;
            background: linear-gradient(to right, #d0e2f0, white, #d0e2f0);
            margin: 2.8rem 0;
        }

        .badge {
            background: #2c6e8f;
            color: white;
            font-size: 0.8rem;
            padding: 0.2rem 1.2rem;
            border-radius: 40px;
            display: inline-block;
            margin: 0.5rem 0;
        }

        blockquote {
            border-left: 6px solid #c9826b;
            background: #f1f7fc;
            padding: 1rem 1.8rem;
            margin: 1.5rem 0;
            border-radius: 1rem;
        }

        .note {
            background: #fff8e7;
            border-left: 6px solid #e6b17e;
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: 1rem;
        }

        /* preserve exactly as source ‚Äì no omissions */
    </style>
</head>

<body>
    <div class="document-wrapper">

        <h1>Manipulating Styles & Classes in JavaScript</h1>

        <!-- TABLE OF CONTENTS (exact copy from source) -->
        <div class="table-of-contents">
            <h2 style="margin-top:0; border-bottom:none;">Table of Contents</h2>
            <ul>
                <li><a href="#introduction">1. Introduction to Style and Class Manipulation</a></li>
                <li><a href="#style-property">2. The `style` Property: Inline Style Manipulation</a></li>
                <li><a href="#classlist-property">3. The `classList` Property: Class Manipulation</a></li>
                <li><a href="#comparative-analysis">4. Comparative Analysis: `style` vs `classList`</a></li>
                <li><a href="#advanced-patterns">5. Advanced Patterns and Best Practices</a></li>
                <li><a href="#performance">6. Performance Considerations</a></li>
                <li><a href="#real-world-applications">7. Real-World Applications and Case Studies</a></li>
                <li><a href="#common-pitfalls">8. Common Pitfalls and Debugging</a></li>
                <li><a href="#interview-questions">9. Interview Questions and Answers</a></li>
                <li><a href="#practice-exercises">10. Practice Exercises and Projects</a></li>
            </ul>
        </div>

        <hr>

        <!-- 1. INTRODUCTION -->
        <h2 id="introduction">1. Introduction to Style and Class Manipulation</h2>
        <h3>1.1 The Importance of Dynamic Styling</h3>
        <p>In modern web development, static websites are a thing of the past. Users expect interactive, responsive
            experiences that react to their actions. JavaScript provides powerful APIs to manipulate the appearance of
            web pages dynamically, with two primary approaches:</p>
        <ol>
            <li><strong>Inline Style Manipulation</strong> - Using the `.style` property</li>
            <li><strong>CSS Class Manipulation</strong> - Using the `.classList` property</li>
        </ol>

        <h3>1.2 The Cascade and Specificity Context</h3>
        <p>Before diving deep into manipulation techniques, understanding the CSS cascade is crucial:</p>
        <pre>/* Specificity hierarchy (from least to most specific) */
* { } /* Universal selector - specificity: 0 */
div { } /* Type selector - specificity: 1 */
.class { } /* Class selector - specificity: 10 */
#id { } /* ID selector - specificity: 100 */
style="color: red" /* Inline style - specificity: 1000 */
!important /* Overrides everything - avoid when possible */</pre>

        <h3>1.3 The DOM Styling Landscape</h3>
        <pre>// Every DOM element has multiple styling interfaces
const element = document.querySelector('.my-element');

// 1. Computed styles (read-only) - actual applied styles
const computed = window.getComputedStyle(element);

// 2. Inline styles (read/write) - directly on the element
element.style.color = 'red';

// 3. Class-based styles (read/write via classList)
element.classList.add('highlight');</pre>

        <hr>

        <!-- 2. STYLE PROPERTY -->
        <h2 id="style-property">2. The `style` Property: Inline Style Manipulation</h2>
        <h3>2.1 Understanding the `style` Object</h3>
        <p>The `style` property is a `CSSStyleDeclaration` object that represents only the <strong>inline
                styles</strong> of an element, not the computed styles from stylesheets.</p>
        <pre>const element = document.querySelector('.card');

// HTML: &lt;div class="card" style="background: blue;"&gt;Hello&lt;/div&gt;
console.log(element.style.background); // "blue"
console.log(element.style.color); // "" (empty if not set inline)</pre>

        <h3>2.2 Setting Inline Styles</h3>
        <h4>Basic Syntax and CamelCase Conversion</h4>
        <p>CSS properties with hyphens become camelCase in JavaScript:</p>
        <pre>const box = document.getElementById('myBox');

// CSS property: background-color
box.style.backgroundColor = '#ff0000';

// CSS property: font-size
box.style.fontSize = '16px';

// CSS property: margin-top
box.style.marginTop = '20px';

// CSS property: border-radius
box.style.borderRadius = '8px';</pre>

        <h4>Setting Multiple Styles Efficiently</h4>
        <pre>// Inefficient way - causes multiple reflows
element.style.color = 'white';
element.style.backgroundColor = 'blue';
element.style.padding = '20px';
element.style.borderRadius = '5px';

// Better approach using Object.assign()
Object.assign(element.style, {
    color: 'white',
    backgroundColor: 'blue',
    padding: '20px',
    borderRadius: '5px',
    transition: 'all 0.3s ease'
});

// Alternative: Using cssText (overwrites all inline styles)
element.style.cssText = 'color: white; background: blue; padding: 20px; border-radius: 5px;';</pre>

        <h3>2.3 Reading Inline Styles</h3>
        <pre>const button = document.querySelector('.btn');

// Reading inline styles (only what's set inline)
button.style.color = 'red';
console.log(button.style.color); // "red"

// Reading computed styles (what's actually applied)
const computedColor = window.getComputedStyle(button).color;
console.log(computedColor); // "rgb(255, 0, 0)"</pre>

        <h3>2.4 Working with CSS Custom Properties (Variables)</h3>
        <pre>const themeSwitcher = document.querySelector('.theme-btn');

// Setting CSS variables on :root
document.documentElement.style.setProperty('--primary-color', '#3498db');
document.documentElement.style.setProperty('--spacing-unit', '8px');

// Reading CSS variables
const primaryColor = getComputedStyle(document.documentElement)
    .getPropertyValue('--primary-color').trim();

// Dynamic theme switching
function setTheme(theme) {
    const root = document.documentElement;
    if (theme === 'dark') {
        root.style.setProperty('--bg-color', '#1a1a1a');
        root.style.setProperty('--text-color', '#ffffff');
        root.style.setProperty('--accent-color', '#4a9eff');
    } else {
        root.style.setProperty('--bg-color', '#ffffff');
        root.style.setProperty('--text-color', '#333333');
        root.style.setProperty('--accent-color', '#0066cc');
    }
}</pre>

        <h3>2.5 Working with Specific Style Properties</h3>
        <h4>Numeric Values and Units</h4>
        <pre>function setElementSize(element, width, height) {
    // Always specify units
    element.style.width = width + 'px';  // Correct
    element.style.height = height + 'px'; // Correct
    
    // Wrong - missing units
    // element.style.width = width; // Browser may ignore this
}

// Helper function for safe unit assignment
function setStyleWithUnit(element, property, value, unit = 'px') {
    if (typeof value === 'number') {
        element.style[property] = value + unit;
    } else {
        element.style[property] = value; // Assume it already has units
    }
}</pre>

        <h4>Transform Properties</h4>
        <pre>const element = document.querySelector('.animated-box');

// Individual transforms
element.style.transform = 'translateX(100px)';
element.style.transform += ' rotate(45deg)'; // Combines transforms

// Complex transforms
function applyTransform(element, options = {}) {
    const transforms = [];
    
    if (options.translateX) transforms.push(`translateX(${options.translateX})`);
    if (options.translateY) transforms.push(`translateY(${options.translateY})`);
    if (options.rotate) transforms.push(`rotate(${options.rotate})`);
    if (options.scale) transforms.push(`scale(${options.scale})`);
    
    element.style.transform = transforms.join(' ');
}

// Usage
applyTransform(element, {
    translateX: '50px',
    rotate: '90deg',
    scale: '1.5'
});</pre>

        <h3>2.6 Removing Inline Styles</h3>
        <pre>const element = document.querySelector('.reset-me');

// Method 1: Set to empty string
element.style.backgroundColor = '';
element.style.padding = '';

// Method 2: Use removeProperty()
element.style.removeProperty('background-color');
element.style.removeProperty('padding');

// Method 3: Reset everything
element.style.cssText = ''; // Removes all inline styles

// Method 4: Specific to CSS variables
element.style.removeProperty('--custom-var');</pre>

        <hr>

        <!-- 3. classList PROPERTY -->
        <h2 id="classlist-property">3. The `classList` Property: Class Manipulation</h2>
        <h3>3.1 Introduction to `classList`</h3>
        <p>The `classList` property provides a powerful, modern API for manipulating classes on DOM elements. It returns
            a live `DOMTokenList` collection of the element's classes.</p>
        <pre>const element = document.querySelector('.my-element');

console.log(element.classList); // DOMTokenList ["class1", "class2", ...]
console.log(element.classList.length); // Number of classes
console.log(Array.from(element.classList)); // Convert to array</pre>

        <h3>3.2 Core Methods of `classList`</h3>
        <h4>`add()` - Adding Classes</h4>
        <pre>const modal = document.getElementById('modal');

// Add a single class
modal.classList.add('visible');

// Add multiple classes at once
modal.classList.add('visible', 'animated', 'shadow-lg');

// Conditional class addition
function showModal(animate = true) {
    modal.classList.add('visible');
    if (animate) {
        modal.classList.add('fade-in');
    }
}

// Safe addition (won't duplicate classes)
modal.classList.add('visible', 'visible'); // Only added once</pre>

        <h4>`remove()` - Removing Classes</h4>
        <pre>const alert = document.querySelector('.alert');

// Remove a single class
alert.classList.remove('hidden');

// Remove multiple classes
alert.classList.remove('warning', 'error', 'info');

// Safe removal (won't error if class doesn't exist)
function hideAlert() {
    alert.classList.remove('visible', 'showing', 'active');
    // No error even if these classes aren't present
}

// Remove all classes
alert.className = ''; // Alternative, but removes all classes</pre>

        <h4>`toggle()` - Toggling Classes</h4>
        <pre>const menu = document.querySelector('.menu');
const button = document.querySelector('.menu-toggle');

// Basic toggle
button.addEventListener('click', () => {
    menu.classList.toggle('open');
});

// Toggle with force parameter
function setMenuState(shouldOpen) {
    // Second parameter forces the state
    menu.classList.toggle('open', shouldOpen);
}

// Multiple toggles
function toggleSidebar(force) {
    sidebar.classList.toggle('expanded', force);
    mainContent.classList.toggle('shrinked', force);
    toggleButton.classList.toggle('rotated', force);
}

// Real-world example: Dark mode toggle
const darkModeToggle = document.getElementById('darkMode');
const body = document.body;

darkModeToggle.addEventListener('click', () => {
    const isDark = body.classList.toggle('dark-theme');
    
    // Update UI based on state
    darkModeToggle.textContent = isDark ? '‚òÄÔ∏è Light' : 'üåô Dark';
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
});</pre>

        <h4>`contains()` - Checking Classes</h4>
        <pre>const dropdown = document.querySelector('.dropdown');

// Check if element has a class
if (dropdown.classList.contains('active')) {
    console.log('Dropdown is active');
}

// Conditional logic with contains
function handleDropdownClick() {
    if (dropdown.classList.contains('disabled')) {
        return; // Do nothing if disabled
    }
    
    if (dropdown.classList.contains('active')) {
        dropdown.classList.remove('active');
    } else {
        dropdown.classList.add('active');
    }
}

// Feature detection style
function hasAnyClass(element, classList) {
    return classList.some(className => 
        element.classList.contains(className)
    );
}

// Usage
if (hasAnyClass(modal, ['success', 'error', 'warning'])) {
    console.log('Modal has a status class');
}</pre>

        <h4>`replace()` - Replacing Classes</h4>
        <pre>const status = document.querySelector('.status');

// Basic replacement
status.classList.replace('error', 'success');

// Complex state management
function updateStatus(newStatus) {
    const statusElement = document.querySelector('.status');
    const validStatuses = ['idle', 'loading', 'success', 'error'];
    
    if (validStatuses.includes(newStatus)) {
        // Remove all status classes first
        validStatuses.forEach(s => statusElement.classList.remove(s));
        // Add the new one
        statusElement.classList.add(newStatus);
        
        // Alternative using replace if you know current status
        // const currentStatus = findCurrentStatus();
        // statusElement.classList.replace(currentStatus, newStatus);
    }
}</pre>

        <h4>`item()` and Index Access</h4>
        <pre>const card = document.querySelector('.card');

// Get class at specific index
const firstClass = card.classList.item(0);
const secondClass = card.classList[1]; // Array-like access

// Iterate over classes
for (let i = 0; i &lt; card.classList.length; i++) {
    console.log(`Class ${i}: ${card.classList[i]}`);
}

// Modern iteration
card.classList.forEach((className, index) => {
    console.log(`${index}: ${className}`);
});</pre>

        <h3>3.3 Advanced `classList` Patterns</h3>
        <h4>Chaining Methods</h4>
        <pre>// Note: classList methods return void, so you can't chain them directly
// But you can chain in a single statement:

element.classList.add('class1');
element.classList.add('class2');
element.classList.remove('class3');

// Better grouping:
const classesToAdd = ['class1', 'class2'];
const classesToRemove = ['class3'];

classesToAdd.forEach(c => element.classList.add(c));
classesToRemove.forEach(c => element.classList.remove(c));

// Or use a helper
function updateClasses(element, add = [], remove = []) {
    add.forEach(c => element.classList.add(c));
    remove.forEach(c => element.classList.remove(c));
}</pre>

        <h4>Conditional Class Management</h4>
        <pre>// Form validation example
function validateInput(input) {
    const isValid = input.value.length >= 3;
    
    // Clean approach
    input.classList.toggle('valid', isValid);
    input.classList.toggle('invalid', !isValid);
    
    // Update sibling elements
    const feedback = input.nextElementSibling;
    if (feedback &amp;&amp; feedback.classList.contains('feedback')) {
        feedback.classList.toggle('visible', !isValid);
        feedback.textContent = isValid ? '' : 'Minimum 3 characters required';
    }
    
    return isValid;
}

// Multi-condition styling
function updateButtonState(button, state) {
    // Reset states
    button.classList.remove('loading', 'success', 'error', 'disabled');
    
    // Apply new state
    switch(state) {
        case 'loading':
            button.classList.add('loading');
            button.disabled = true;
            break;
        case 'success':
            button.classList.add('success');
            button.disabled = false;
            break;
        case 'error':
            button.classList.add('error');
            button.disabled = false;
            break;
        case 'disabled':
            button.classList.add('disabled');
            button.disabled = true;
            break;
    }
}</pre>

        <hr>

        <!-- 4. COMPARATIVE ANALYSIS -->
        <h2 id="comparative-analysis">4. Comparative Analysis: `style` vs `classList`</h2>
        <h3>4.1 When to Use Each</h3>
        <table>
            <tr>
                <th>Scenario</th>
                <th>Use `style`</th>
                <th>Use `classList`</th>
                <th>Reason</th>
            </tr>
            <tr>
                <td>Dynamic values (e.g., mouse position)</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
                <td>Values change continuously</td>
            </tr>
            <tr>
                <td>Theming/Skinning</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>Better separation of concerns</td>
            </tr>
            <tr>
                <td>Animations</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>CSS transitions are more efficient</td>
            </tr>
            <tr>
                <td>One-off styling</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
                <td>Quick, unique changes</td>
            </tr>
            <tr>
                <td>Responsive design</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>Media queries work with classes</td>
            </tr>
            <tr>
                <td>Component states</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>Active, disabled, hover states</td>
            </tr>
            <tr>
                <td>Third-party integration</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>Depends on the API requirements</td>
            </tr>
        </table>

        <h3>4.2 Performance Comparison</h3>
        <pre>// Performance test example
function benchmarkStyleVsClass() {
    const div = document.createElement('div');
    document.body.appendChild(div);
    
    console.time('style');
    for (let i = 0; i &lt; 1000; i++) {
        div.style.color = 'red';
        div.style.backgroundColor = 'blue';
        div.style.padding = '10px';
    }
    console.timeEnd('style'); // Usually slower
    
    console.time('classList');
    for (let i = 0; i &lt; 1000; i++) {
        div.classList.add('styled');
        div.classList.remove('styled');
    }
    console.timeEnd('classList'); // Usually faster
    
    document.body.removeChild(div);
}</pre>

        <h3>4.3 Separation of Concerns</h3>
        <pre>// BAD: Mixing styling with logic
function createErrorMessage(text) {
    const error = document.createElement('div');
    error.textContent = text;
    error.style.color = 'red';
    error.style.backgroundColor = '#ffeeee';
    error.style.padding = '10px';
    error.style.borderRadius = '4px';
    error.style.border = '1px solid #ffcccc';
    return error;
}

// GOOD: Using classes for presentation
function createErrorMessage(text) {
    const error = document.createElement('div');
    error.textContent = text;
    error.classList.add('error-message', 'animated', 'fade-in');
    return error;
}

/* CSS file */
.error-message {
    color: red;
    background-color: #ffeeee;
    padding: 10px;
    border-radius: 4px;
    border: 1px solid #ffcccc;
}</pre>

        <hr>

        <!-- 5. ADVANCED PATTERNS -->
        <h2 id="advanced-patterns">5. Advanced Patterns and Best Practices</h2>
        <h3>5.1 Style Manager Utility</h3>
        <pre>class StyleManager {
    constructor(element) {
        this.element = element;
        this.inlineStyles = new Map();
        this.classStates = new Set();
    }
    
    // Inline style management
    setStyles(styles) {
        Object.assign(this.element.style, styles);
        Object.entries(styles).forEach(([key, value]) => {
            this.inlineStyles.set(key, value);
        });
        return this;
    }
    
    getStyle(property) {
        return this.element.style[property] || this.inlineStyles.get(property);
    }
    
    removeStyles(properties) {
        properties.forEach(prop => {
            this.element.style[prop] = '';
            this.inlineStyles.delete(prop);
        });
        return this;
    }
    
    // Class management
    addClasses(...classes) {
        classes.forEach(c => this.classStates.add(c));
        this.element.classList.add(...classes);
        return this;
    }
    
    removeClasses(...classes) {
        classes.forEach(c => this.classStates.delete(c));
        this.element.classList.remove(...classes);
        return this;
    }
    
    toggleClass(className, force) {
        const hasClass = this.element.classList.toggle(className, force);
        if (hasClass) {
            this.classStates.add(className);
        } else {
            this.classStates.delete(className);
        }
        return this;
    }
    
    // State persistence
    saveState(key = 'default') {
        const state = {
            inlineStyles: Object.fromEntries(this.inlineStyles),
            classes: Array.from(this.classStates)
        };
        localStorage.setItem(`styleState_${key}`, JSON.stringify(state));
        return this;
    }
    
    restoreState(key = 'default') {
        const saved = localStorage.getItem(`styleState_${key}`);
        if (saved) {
            const state = JSON.parse(saved);
            
            // Restore inline styles
            this.element.style.cssText = '';
            Object.entries(state.inlineStyles).forEach(([prop, value]) => {
                this.element.style[prop] = value;
                this.inlineStyles.set(prop, value);
            });
            
            // Restore classes
            this.element.className = '';
            state.classes.forEach(c => {
                this.element.classList.add(c);
                this.classStates.add(c);
            });
        }
        return this;
    }
    
    // Reset everything
    reset() {
        this.element.style.cssText = '';
        this.element.className = '';
        this.inlineStyles.clear();
        this.classStates.clear();
        return this;
    }
}

// Usage
const manager = new StyleManager(document.querySelector('.my-element'));
manager
    .setStyles({ color: 'blue', fontSize: '16px' })
    .addClasses('active', 'highlighted')
    .saveState('component1');</pre>

        <h3>5.2 Animation Controller</h3>
        <pre>class AnimationController {
    constructor(element) {
        this.element = element;
        this.animations = new Map();
    }
    
    // CSS class-based animation
    playClassAnimation(className, duration = 300) {
        return new Promise((resolve) => {
            this.element.classList.add(className);
            
            setTimeout(() => {
                this.element.classList.remove(className);
                resolve();
            }, duration);
        });
    }
    
    // Inline style animation
    playInlineAnimation(keyframes, duration = 300) {
        return new Promise((resolve) => {
            const startTime = performance.now();
            
            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Interpolate between keyframes
                const currentStyles = {};
                Object.keys(keyframes[0]).forEach(prop => {
                    const startValue = parseFloat(keyframes[0][prop]);
                    const endValue = parseFloat(keyframes[1][prop]);
                    const unit = keyframes[0][prop].replace(startValue, '') || 'px';
                    
                    currentStyles[prop] = (startValue + (endValue - startValue) * progress) + unit;
                });
                
                Object.assign(this.element.style, currentStyles);
                
                if (progress &lt; 1) {
                    requestAnimationFrame(animate);
                } else {
                    resolve();
                }
            };
            
            requestAnimationFrame(animate);
        });
    }
    
    // Shake animation example
    shake(intensity = 5) {
        const originalTransform = this.element.style.transform;
        
        this.element.style.transition = 'transform 0.05s';
        
        for (let i = 0; i &lt; 10; i++) {
            setTimeout(() => {
                const x = (i % 2 === 0 ? 1 : -1) * intensity * (10 - i) / 10;
                this.element.style.transform = `translateX(${x}px)`;
            }, i * 50);
        }
        
        setTimeout(() => {
            this.element.style.transform = originalTransform;
            this.element.style.transition = '';
        }, 500);
    }
}

// Usage
const animator = new AnimationController(document.querySelector('.box'));
await animator.playClassAnimation('fade-out', 500);
animator.shake(10);</pre>

        <h3>5.3 Responsive Class Manager</h3>
        <pre>class ResponsiveClassManager {
    constructor(breakpoints = {
        mobile: 480,
        tablet: 768,
        desktop: 1024,
        wide: 1280
    }) {
        this.breakpoints = breakpoints;
        this.elements = new Map();
        this.currentBreakpoint = this.getCurrentBreakpoint();
        
        // Listen for resize events
        window.addEventListener('resize', this.handleResize.bind(this));
    }
    
    getCurrentBreakpoint() {
        const width = window.innerWidth;
        if (width &lt; this.breakpoints.mobile) return 'xs';
        if (width &lt; this.breakpoints.tablet) return 'mobile';
        if (width &lt; this.breakpoints.desktop) return 'tablet';
        if (width &lt; this.breakpoints.wide) return 'desktop';
        return 'wide';
    }
    
    handleResize() {
        const newBreakpoint = this.getCurrentBreakpoint();
        
        if (newBreakpoint !== this.currentBreakpoint) {
            this.currentBreakpoint = newBreakpoint;
            this.updateAllElements();
        }
    }
    
    register(elementId, classMap) {
        // classMap = { mobile: 'mobile-layout', desktop: 'desktop-layout' }
        this.elements.set(elementId, {
            element: document.getElementById(elementId),
            classMap
        });
        this.updateElement(elementId);
    }
    
    updateElement(elementId) {
        const item = this.elements.get(elementId);
        if (!item) return;
        
        const { element, classMap } = item;
        
        // Remove all responsive classes
        Object.values(classMap).forEach(className => {
            element.classList.remove(className);
        });
        
        // Add appropriate class for current breakpoint
        const responsiveClass = classMap[this.currentBreakpoint] || 
                               classMap[Object.keys(classMap)[0]];
        if (responsiveClass) {
            element.classList.add(responsiveClass);
        }
    }
    
    updateAllElements() {
        this.elements.forEach((_, elementId) => {
            this.updateElement(elementId);
        });
    }
}

// Usage
const responsiveManager = new ResponsiveClassManager();
responsiveManager.register('sidebar', {
    xs: 'sidebar-hidden',
    mobile: 'sidebar-drawer',
    tablet: 'sidebar-collapsed',
    desktop: 'sidebar-expanded',
    wide: 'sidebar-wide'
});</pre>

        <hr>

        <!-- 6. PERFORMANCE -->
        <h2 id="performance">6. Performance Considerations</h2>
        <h3>6.1 Reflow and Repaint</h3>
        <pre>// BAD: Causes multiple reflows
function badStyleUpdates(element) {
    element.style.width = '100px';  // reflow
    element.style.height = '100px'; // reflow
    element.style.margin = '10px';  // reflow
    element.style.padding = '5px';  // reflow
}

// GOOD: Batch updates
function goodStyleUpdates(element) {
    // Use cssText
    element.style.cssText = 'width: 100px; height: 100px; margin: 10px; padding: 5px;';
    
    // OR use classList
    element.classList.add('box-styles');
    
    // OR use a fragment/documentFragment for multiple elements
}

// Using requestAnimationFrame for visual updates
function smoothUpdate(element, targetWidth) {
    function animate() {
        const currentWidth = parseInt(getComputedStyle(element).width);
        if (currentWidth &lt; targetWidth) {
            element.style.width = (currentWidth + 1) + 'px';
            requestAnimationFrame(animate);
        }
    }
    requestAnimationFrame(animate);
}</pre>

        <h3>6.2 Efficient Class Manipulation</h3>
        <pre>// BAD: Multiple class operations
function badClassUpdates(element) {
    element.classList.remove('hidden');
    element.classList.add('visible');
    element.classList.add('animated');
    element.classList.remove('loading');
}

// GOOD: Batch operations
function goodClassUpdates(element) {
    element.classList.remove('hidden', 'loading');
    element.classList.add('visible', 'animated');
}

// For large lists, use a document fragment
function addClassToMany(elements, className) {
    // Use setTimeout to break up heavy operations
    setTimeout(() => {
        elements.forEach((el, index) => {
            // Use requestAnimationFrame for each batch
            requestAnimationFrame(() => {
                el.classList.add(className);
            });
        });
    }, 0);
}</pre>

        <hr>

        <!-- 7. REAL-WORLD APPLICATIONS -->
        <h2 id="real-world-applications">7. Real-World Applications and Case Studies</h2>
        <h3>7.1 Theme Switcher Implementation</h3>
        <pre>class ThemeSwitcher {
    constructor() {
        this.themes = {
            light: {
                name: 'Light',
                icon: '‚òÄÔ∏è',
                classes: ['theme-light', 'light-mode']
            },
            dark: {
                name: 'Dark',
                icon: 'üåô',
                classes: ['theme-dark', 'dark-mode']
            },
            sepia: {
                name: 'Sepia',
                icon: 'üìú',
                classes: ['theme-sepia', 'sepia-mode']
            }
        };
        
        this.currentTheme = localStorage.getItem('theme') || 'light';
        this.init();
    }
    
    init() {
        this.createThemeToggle();
        this.applyTheme(this.currentTheme);
        this.listenForSystemPreference();
    }
    
    createThemeToggle() {
        const toggle = document.createElement('div');
        toggle.className = 'theme-toggle';
        toggle.innerHTML = `
            &lt;button class="theme-btn" aria-label="Toggle theme"&gt;
                ${this.themes[this.currentTheme].icon}
                &lt;span&gt;${this.themes[this.currentTheme].name}&lt;/span&gt;
            &lt;/button&gt;
            &lt;div class="theme-menu hidden"&gt;
                ${Object.entries(this.themes).map(([key, theme]) => `
                    &lt;button data-theme="${key}" class="theme-option ${key === this.currentTheme ? 'active' : ''}"&gt;
                        ${theme.icon} ${theme.name}
                    &lt;/button&gt;
                `).join('')}
            &lt;/div&gt;
        `;
        
        document.body.appendChild(toggle);
        
        // Add event listeners
        const btn = toggle.querySelector('.theme-btn');
        const menu = toggle.querySelector('.theme-menu');
        const options = toggle.querySelectorAll('.theme-option');
        
        btn.addEventListener('click', () => {
            menu.classList.toggle('hidden');
        });
        
        options.forEach(opt => {
            opt.addEventListener('click', (e) => {
                const theme = e.target.dataset.theme;
                this.applyTheme(theme);
                menu.classList.add('hidden');
                
                // Update button
                btn.innerHTML = `${this.themes[theme].icon} &lt;span&gt;${this.themes[theme].name}&lt;/span&gt;`;
                
                // Update active states
                options.forEach(o => o.classList.remove('active'));
                opt.classList.add('active');
            });
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!toggle.contains(e.target)) {
                menu.classList.add('hidden');
            }
        });
    }
    
    applyTheme(themeName) {
        const body = document.body;
        const theme = this.themes[themeName];
        
        // Remove all theme classes
        Object.values(this.themes).forEach(t => {
            t.classes.forEach(c => body.classList.remove(c));
        });
        
        // Add new theme classes
        theme.classes.forEach(c => body.classList.add(c));
        
        // Update CSS variables
        this.updateCSSVariables(themeName);
        
        // Save preference
        localStorage.setItem('theme', themeName);
        this.currentTheme = themeName;
        
        // Dispatch event for other components
        window.dispatchEvent(new CustomEvent('themechange', { detail: themeName }));
    }
    
    updateCSSVariables(theme) {
        const root = document.documentElement;
        const variables = {
            light: {
                '--bg-primary': '#ffffff',
                '--text-primary': '#333333',
                '--accent-color': '#0066cc'
            },
            dark: {
                '--bg-primary': '#1a1a1a',
                '--text-primary': '#ffffff',
                '--accent-color': '#4a9eff'
            },
            sepia: {
                '--bg-primary': '#f4ecd8',
                '--text-primary': '#5b4636',
                '--accent-color': '#8b6b4d'
            }
        };
        
        Object.entries(variables[theme]).forEach(([key, value]) => {
            root.style.setProperty(key, value);
        });
    }
    
    listenForSystemPreference() {
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        mediaQuery.addListener((e) => {
            if (!localStorage.getItem('theme')) {
                this.applyTheme(e.matches ? 'dark' : 'light');
            }
        });
    }
}

// Initialize
new ThemeSwitcher();</pre>

        <h3>7.2 Drag-and-Drop with Style Manipulation</h3>
        <pre>class Draggable {
    constructor(element, options = {}) {
        this.element = element;
        this.handle = options.handle || element;
        this.boundary = options.boundary || document.body;
        
        this.isDragging = false;
        this.startX = 0;
        this.startY = 0;
        this.initialLeft = 0;
        this.initialTop = 0;
        
        this.init();
    }
    
    init() {
        // Set initial styles
        this.element.classList.add('draggable');
        Object.assign(this.element.style, {
            position: 'absolute',
            cursor: 'move',
            userSelect: 'none',
            transition: 'none'
        });
        
        // Event listeners
        this.handle.addEventListener('mousedown', this.startDrag.bind(this));
        document.addEventListener('mousemove', this.drag.bind(this));
        document.addEventListener('mouseup', this.stopDrag.bind(this));
        
        // Optional: touch events for mobile
        this.handle.addEventListener('touchstart', this.startDrag.bind(this));
        document.addEventListener('touchmove', this.drag.bind(this));
        document.addEventListener('touchend', this.stopDrag.bind(this));
    }
    
    startDrag(e) {
        e.preventDefault();
        
        // Prevent dragging if clicking on interactive elements
        if (e.target.closest('button, a, input')) return;
        
        this.isDragging = true;
        
        // Get coordinates
        const clientX = e.clientX ?? e.touches[0].clientX;
        const clientY = e.clientY ?? e.touches[0].clientY;
        
        // Get current position
        const rect = this.element.getBoundingClientRect();
        this.startX = clientX;
        this.startY = clientY;
        this.initialLeft = rect.left;
        this.initialTop = rect.top;
        
        // Add dragging class
        this.element.classList.add('dragging');
        
        // Dispatch event
        this.element.dispatchEvent(new CustomEvent('dragstart', {
            detail: { x: clientX, y: clientY }
        }));
    }
    
    drag(e) {
        if (!this.isDragging) return;
        e.preventDefault();
        
        // Get coordinates
        const clientX = e.clientX ?? e.touches[0].clientX;
        const clientY = e.clientY ?? e.touches[0].clientY;
        
        // Calculate new position
        let newLeft = this.initialLeft + (clientX - this.startX);
        let newTop = this.initialTop + (clientY - this.startY);
        
        // Apply boundaries
        const boundaryRect = this.boundary.getBoundingClientRect();
        const elementRect = this.element.getBoundingClientRect();
        
        newLeft = Math.max(boundaryRect.left, Math.min(newLeft, boundaryRect.right - elementRect.width));
        newTop = Math.max(boundaryRect.top, Math.min(newTop, boundaryRect.bottom - elementRect.height));
        
        // Apply styles
        Object.assign(this.element.style, {
            left: newLeft + 'px',
            top: newTop + 'px',
            transform: 'none' // Ensure transform doesn't interfere
        });
        
        // Dispatch event
        this.element.dispatchEvent(new CustomEvent('drag', {
            detail: { x: clientX, y: clientY, left: newLeft, top: newTop }
        }));
    }
    
    stopDrag(e) {
        if (!this.isDragging) return;
        
        this.isDragging = false;
        this.element.classList.remove('dragging');
        
        // Dispatch event
        this.element.dispatchEvent(new CustomEvent('dragend', {
            detail: { 
                x: e.clientX, 
                y: e.clientY,
                left: parseInt(this.element.style.left),
                top: parseInt(this.element.style.top)
            }
        }));
    }
}

// Usage
const box = document.getElementById('draggable-box');
const draggable = new Draggable(box, {
    boundary: document.querySelector('.container')
});

// Add snap-to-grid feature
box.addEventListener('dragend', (e) => {
    const gridSize = 20;
    const left = Math.round(e.detail.left / gridSize) * gridSize;
    const top = Math.round(e.detail.top / gridSize) * gridSize;
    
    box.style.left = left + 'px';
    box.style.top = top + 'px';
});</pre>

        <h3>7.3 Dynamic Form Validation with Visual Feedback</h3>
        <pre>class FormValidator {
    constructor(formElement) {
        this.form = formElement;
        this.fields = new Map();
        this.init();
    }
    
    init() {
        // Add validation classes to form
        this.form.classList.add('validated-form');
        
        // Setup all inputs
        const inputs = this.form.querySelectorAll('input, textarea, select');
        inputs.forEach(input => {
            this.setupField(input);
        });
        
        // Handle form submission
        this.form.addEventListener('submit', this.handleSubmit.bind(this));
    }
    
    setupField(field) {
        const config = {
            element: field,
            valid: false,
            touched: false,
            rules: this.getFieldRules(field),
            errorElement: this.createErrorElement(field)
        };
        
        this.fields.set(field, config);
        
        // Add input classes
        field.classList.add('form-field');
        
        // Event listeners
        field.addEventListener('input', () => this.validateField(field));
        field.addEventListener('blur', () => this.validateField(field, true));
        field.addEventListener('focus', () => {
            field.classList.add('focused');
        });
        field.addEventListener('blur', () => {
            field.classList.remove('focused');
        });
    }
    
    getFieldRules(field) {
        const rules = [];
        
        if (field.required) {
            rules.push({
                test: (value) => value.trim() !== '',
                message: 'This field is required'
            });
        }
        
        if (field.type === 'email') {
            rules.push({
                test: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
                message: 'Please enter a valid email address'
            });
        }
        
        if (field.minLength) {
            rules.push({
                test: (value) => value.length >= field.minLength,
                message: `Minimum ${field.minLength} characters required`
            });
        }
        
        if (field.pattern) {
            const pattern = new RegExp(field.pattern);
            rules.push({
                test: (value) => pattern.test(value),
                message: field.title || 'Please match the requested format'
            });
        }
        
        return rules;
    }
    
    createErrorElement(field) {
        const error = document.createElement('div');
        error.className = 'field-error hidden';
        error.setAttribute('aria-live', 'polite');
        field.parentNode.insertBefore(error, field.nextSibling);
        return error;
    }
    
    validateField(field, isBlur = false) {
        const config = this.fields.get(field);
        if (!config) return true;
        
        if (isBlur) {
            config.touched = true;
        }
        
        const value = field.value;
        let isValid = true;
        let errorMessage = '';
        
        // Run all validation rules
        for (const rule of config.rules) {
            if (!rule.test(value)) {
                isValid = false;
                errorMessage = rule.message;
                break;
            }
        }
        
        config.valid = isValid;
        
        // Update classes
        this.updateFieldClasses(field, config);
        
        // Update error message
        this.updateErrorMessage(field, config, errorMessage);
        
        return isValid;
    }
    
    updateFieldClasses(field, config) {
        // Remove existing validation classes
        field.classList.remove('valid', 'invalid', 'touched', 'pristine');
        
        // Add appropriate classes
        if (config.touched) {
            field.classList.add('touched');
        } else {
            field.classList.add('pristine');
        }
        
        if (config.valid) {
            field.classList.add('valid');
        } else if (config.touched || (config.rules.some(r => r.test &amp;&amp; field.value !== ''))) {
            field.classList.add('invalid');
        }
        
        // Update parent for better styling
        const parent = field.parentNode;
        if (config.valid) {
            parent.classList.add('has-valid');
            parent.classList.remove('has-error');
        } else if (config.touched &amp;&amp; !config.valid) {
            parent.classList.add('has-error');
            parent.classList.remove('has-valid');
        }
    }
    
    updateErrorMessage(field, config, message) {
        if (!config.errorElement) return;
        
        if (!config.valid &amp;&amp; config.touched &amp;&amp; message) {
            config.errorElement.textContent = message;
            config.errorElement.classList.remove('hidden');
            
            // Add error icon using pseudo-element
            field.style.borderColor = 'var(--error-color)';
        } else {
            config.errorElement.classList.add('hidden');
            field.style.borderColor = '';
        }
    }
    
    validateAllFields() {
        let isFormValid = true;
        
        this.fields.forEach((config, field) => {
            config.touched = true;
            const isValid = this.validateField(field);
            if (!isValid) isFormValid = false;
        });
        
        return isFormValid;
    }
    
    handleSubmit(e) {
        e.preventDefault();
        
        const isValid = this.validateAllFields();
        
        if (isValid) {
            this.form.classList.remove('form-error');
            this.form.classList.add('form-submitting');
            
            // Simulate submission
            setTimeout(() => {
                this.form.classList.remove('form-submitting');
                this.form.classList.add('form-success');
                
                // Show success message
                const successMsg = document.createElement('div');
                successMsg.className = 'success-message';
                successMsg.textContent = 'Form submitted successfully!';
                this.form.appendChild(successMsg);
                
                // Remove success message after 3 seconds
                setTimeout(() => {
                    successMsg.remove();
                    this.form.classList.remove('form-success');
                }, 3000);
            }, 1500);
        } else {
            this.form.classList.add('form-error');
            
            // Scroll to first error
            const firstInvalid = this.form.querySelector('.invalid');
            if (firstInvalid) {
                firstInvalid.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    }
}

// Usage
const form = document.getElementById('registration-form');
const validator = new FormValidator(form);

// Add custom validation rule
const passwordField = form.querySelector('#password');
validator.fields.get(passwordField).rules.push({
    test: (value) => /[A-Z]/.test(value),
    message: 'Must contain at least one uppercase letter'
});</pre>

        <hr>

        <!-- 8. COMMON PITFALLS -->
        <h2 id="common-pitfalls">8. Common Pitfalls and Debugging</h2>
        <h3>8.1 Pitfall: Forgetting Units</h3>
        <pre>// WRONG
element.style.width = 100;
element.style.fontSize = 12;
element.style.padding = 10;

// RIGHT
element.style.width = '100px';
element.style.fontSize = '12px';
element.style.padding = '10px';

// Helper function to auto-add units
function px(value) {
    return typeof value === 'number' ? value + 'px' : value;
}

element.style.width = px(100);
element.style.margin = px(20);</pre>

        <h3>8.2 Pitfall: Specificity Wars</h3>
        <pre>// Problem: Inline styles are hard to override
element.style.color = 'red';

/* CSS won't override this without !important */
// .element { color: blue !important; } // Bad practice

// Solution: Use classList with high specificity
element.classList.add('theme-color');

/* CSS */
body .element.theme-color { color: blue; } // Higher specificity</pre>

        <h3>8.3 Debugging Techniques</h3>
        <pre>class StyleDebugger {
    constructor() {
        this.debugMode = false;
    }
    
    enable() {
        this.debugMode = true;
        this.instrumentElement(document.body);
    }
    
    instrumentElement(element) {
        if (!this.debugMode) return;
        
        // Log style changes
        const originalStyleSet = Object.getOwnPropertyDescriptor(Element.prototype, 'style').set;
        
        Object.defineProperty(element, 'style', {
            set(value) {
                console.log('Style changed:', value);
                console.trace('Style change trace');
                originalStyleSet.call(this, value);
            }
        });
        
        // Monitor class changes
        const classList = element.classList;
        const originalAdd = classList.add;
        const originalRemove = classList.remove;
        const originalToggle = classList.toggle;
        
        classList.add = function(...classes) {
            console.log(`Adding classes: ${classes.join(', ')}`);
            console.trace();
            return originalAdd.apply(this, classes);
        };
        
        classList.remove = function(...classes) {
            console.log(`Removing classes: ${classes.join(', ')}`);
            return originalRemove.apply(this, classes);
        };
        
        classList.toggle = function(className, force) {
            const result = originalToggle.call(this, className, force);
            console.log(`Toggling ${className}: ${result ? 'added' : 'removed'}`);
            return result;
        };
    }
    
    analyzeElement(element) {
        console.group(`Style Analysis for ${element.tagName}`);
        
        // Show all classes
        console.log('Classes:', Array.from(element.classList));
        
        // Show computed styles
        const computed = getComputedStyle(element);
        const importantStyles = ['display', 'position', 'visibility', 'opacity'];
        console.log('Key computed styles:');
        importantStyles.forEach(style => {
            console.log(`  ${style}: ${computed[style]}`);
        });
        
        // Show inline styles
        console.log('Inline styles:', element.style.cssText || 'none');
        
        // Check for specificity conflicts
        console.log('Specificity check:', this.checkSpecificity(element));
        
        console.groupEnd();
    }
    
    checkSpecificity(element) {
        const computed = getComputedStyle(element);
        const inlineStyles = element.style;
        const conflicts = [];
        
        // Compare inline vs computed for potential conflicts
        for (let i = 0; i &lt; inlineStyles.length; i++) {
            const prop = inlineStyles[i];
            const inlineValue = inlineStyles[prop];
            const computedValue = computed[prop];
            
            if (inlineValue &amp;&amp; inlineValue !== computedValue) {
                conflicts.push({
                    property: prop,
                    inline: inlineValue,
                    computed: computedValue,
                    reason: 'Overridden by CSS with higher specificity'
                });
            }
        }
        
        return conflicts;
    }
}</pre>

        <hr>

        <!-- 9. INTERVIEW QUESTIONS -->
        <h2 id="interview-questions">9. Interview Questions and Answers</h2>
        <h3>9.1 Basic Level Questions</h3>
        <p><strong>Q1: What's the difference between `element.style.color` and
                `getComputedStyle(element).color`?</strong></p>
        <p><strong>A:</strong> `element.style.color` only accesses inline styles set directly on the element.
            `getComputedStyle()` returns the actual applied style after considering all CSS sources (inline,
            stylesheets, browser defaults).</p>
        <pre>// HTML: &lt;div class="text"&gt;Hello&lt;/div&gt;
// CSS: .text { color: blue; }

const div = document.querySelector('.text');
console.log(div.style.color); // "" (empty)
console.log(getComputedStyle(div).color); // "rgb(0, 0, 255)"</pre>

        <p><strong>Q2: How do you add multiple classes to an element?</strong></p>
        <p><strong>A:</strong> Using `classList.add()`:</p>
        <pre>element.classList.add('class1', 'class2', 'class3');
// Or with an array
['class1', 'class2'].forEach(c => element.classList.add(c));</pre>

        <h3>9.2 Intermediate Level Questions</h3>
        <p><strong>Q3: Explain the performance implications of manipulating styles vs classes.</strong></p>
        <p><strong>A:</strong> Class manipulation is generally more performant because:</p>
        <ol>
            <li>Class changes trigger repaints/reflows, but the browser can optimize them</li>
            <li>Style changes are often more specific and can't be cached as efficiently</li>
            <li>Classes promote CSS reuse and smaller JavaScript bundles</li>
            <li>CSS transitions/animations run on the compositor thread, not the main thread</li>
        </ol>

        <p><strong>Q4: How would you implement a smooth height transition for an element with dynamic content?</strong>
        </p>
        <p><strong>A:</strong></p>
        <pre>function smoothHeight(element) {
    // Get natural height
    element.style.height = 'auto';
    const autoHeight = getComputedStyle(element).height;
    element.style.height = '0';
    
    // Force reflow
    element.offsetHeight;
    
    // Animate
    element.style.transition = 'height 0.3s ease';
    element.style.height = autoHeight;
    
    // Clean up after animation
    setTimeout(() => {
        element.style.transition = '';
        element.style.height = 'auto';
    }, 300);
}</pre>

        <h3>9.3 Advanced Level Questions</h3>
        <p><strong>Q5: Create a function that toggles classes based on media queries without CSS @media</strong></p>
        <p><strong>A:</strong></p>
        <pre>function createResponsiveToggler(element, classMap) {
    const queries = Object.keys(classMap).map(breakpoint => {
        const mq = window.matchMedia(`(min-width: ${breakpoint})`);
        return { mq, className: classMap[breakpoint] };
    });
    
    function update() {
        queries.forEach(({ mq, className }) => {
            element.classList.toggle(className, mq.matches);
        });
    }
    
    queries.forEach(({ mq }) => {
        mq.addListener(update);
    });
    
    update(); // Initial call
    
    return {
        destroy: () => {
            queries.forEach(({ mq }) => {
                mq.removeListener(update);
            });
        }
    };
}

// Usage
const toggler = createResponsiveToggler(document.body, {
    '768px': 'tablet-layout',
    '1024px': 'desktop-layout',
    '1280px': 'wide-layout'
});</pre>

        <hr>

        <!-- 10. PRACTICE EXERCISES -->
        <h2 id="practice-exercises">10. Practice Exercises and Projects</h2>
        <h3>Exercise 1: Interactive Color Picker</h3>
        <pre>// Build a color picker that updates multiple elements
function createColorPicker() {
    const colorInput = document.createElement('input');
    colorInput.type = 'color';
    
    colorInput.addEventListener('input', (e) => {
        const color = e.target.value;
        
        // Update multiple elements
        document.body.style.backgroundColor = color + '20'; // 20% opacity
        document.querySelectorAll('.accent').forEach(el => {
            el.style.backgroundColor = color;
        });
        document.documentElement.style.setProperty('--accent-color', color);
    });
    
    return colorInput;
}</pre>

        <h3>Exercise 2: Progress Bar with Animation</h3>
        <pre>class ProgressBar {
    constructor(container, options = {}) {
        this.container = container;
        this.progress = 0;
        this.options = {
            height: '20px',
            color: '#4caf50',
            ...options
        };
        
        this.create();
    }
    
    create() {
        this.bar = document.createElement('div');
        this.bar.className = 'progress-bar';
        Object.assign(this.bar.style, {
            width: '0%',
            height: this.options.height,
            backgroundColor: this.options.color,
            transition: 'width 0.3s ease',
            borderRadius: '4px'
        });
        
        this.container.appendChild(this.bar);
    }
    
    setProgress(percent) {
        this.progress = Math.min(100, Math.max(0, percent));
        this.bar.style.width = this.progress + '%';
        
        // Change color based on progress
        if (this.progress &lt; 30) {
            this.bar.style.backgroundColor = '#f44336'; // Red
        } else if (this.progress &lt; 70) {
            this.bar.style.backgroundColor = '#ff9800'; // Orange
        } else {
            this.bar.style.backgroundColor = '#4caf50'; // Green
        }
        
        // Add text
        this.bar.textContent = this.progress + '%';
    }
    
    animateTo(targetPercent, duration = 1000) {
        const start = this.progress;
        const startTime = performance.now();
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const current = start + (targetPercent - start) * progress;
            this.setProgress(current);
            
            if (progress &lt; 1) {
                requestAnimationFrame(animate);
            }
        };
        
        requestAnimationFrame(animate);
    }
}</pre>

        <h3>Exercise 3: Modal with Class-Based States</h3>
        <pre>class Modal {
    constructor(options = {}) {
        this.options = {
            closeOnEsc: true,
            closeOnOverlay: true,
            ...options
        };
        
        this.create();
    }
    
    create() {
        // Create overlay
        this.overlay = document.createElement('div');
        this.overlay.className = 'modal-overlay';
        
        // Create modal
        this.modal = document.createElement('div');
        this.modal.className = 'modal';
        
        // Create content
        this.content = document.createElement('div');
        this.content.className = 'modal-content';
        
        // Create close button
        this.closeBtn = document.createElement('button');
        this.closeBtn.className = 'modal-close';
        this.closeBtn.innerHTML = '&amp;times;';
        
        // Assemble
        this.modal.appendChild(this.closeBtn);
        this.modal.appendChild(this.content);
        this.overlay.appendChild(this.modal);
        document.body.appendChild(this.overlay);
        
        // Add event listeners
        this.closeBtn.addEventListener('click', () => this.close());
        
        if (this.options.closeOnOverlay) {
            this.overlay.addEventListener('click', (e) => {
                if (e.target === this.overlay) {
                    this.close();
                }
            });
        }
        
        if (this.options.closeOnEsc) {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' &amp;&amp; this.isOpen()) {
                    this.close();
                }
            });
        }
    }
    
    setContent(html) {
        this.content.innerHTML = html;
    }
    
    open() {
        this.overlay.classList.add('visible');
        this.modal.classList.add('open');
        document.body.classList.add('modal-open');
        
        // Trigger animation classes
        setTimeout(() => {
            this.modal.classList.add('opened');
        }, 10);
    }
    
    close() {
        this.modal.classList.remove('opened');
        this.modal.classList.add('closing');
        
        setTimeout(() => {
            this.overlay.classList.remove('visible');
            this.modal.classList.remove('open', 'closing');
            document.body.classList.remove('modal-open');
        }, 300); // Match CSS transition
    }
    
    isOpen() {
        return this.overlay.classList.contains('visible');
    }
    
    toggle() {
        if (this.isOpen()) {
            this.close();
        } else {
            this.open();
        }
    }
}

// Usage
const modal = new Modal();
modal.setContent('&lt;h2&gt;Hello World&lt;/h2&gt;&lt;p&gt;This is a modal dialog&lt;/p&gt;');
document.querySelector('#open-modal').addEventListener('click', () => {
    modal.open();
});</pre>

        <hr>

        <h2>Conclusion</h2>
        <p>Mastering style and class manipulation in JavaScript is fundamental to creating dynamic, interactive web
            applications. Remember these key principles:</p>
        <ol>
            <li><strong>Use classes for state-based styling</strong> - They're more maintainable and performant</li>
            <li><strong>Use inline styles for dynamic values</strong> - When values change frequently (like mouse
                position)</li>
            <li><strong>Always consider performance</strong> - Batch updates and use `requestAnimationFrame` for
                animations</li>
            <li><strong>Separate concerns</strong> - Keep styling in CSS when possible, use JavaScript for behavior</li>
            <li><strong>Test across browsers</strong> - While modern browsers are consistent, always verify behavior
            </li>
            <li><strong>Accessibility matters</strong> - Ensure dynamic style changes don't break accessibility</li>
        </ol>
        <p>The examples and patterns provided here cover most real-world scenarios you'll encounter. Practice
            implementing these patterns in your projects to build intuition and expertise.</p>

        <!-- FINAL VERIFICATION NOTE -->
        <p
            style="margin-top:3rem; border-top:2px solid #c9826b; padding-top:1rem; text-align:center; font-weight:bold;">
            ‚úì EVERY LINE, HEADING, CODE BLOCK, AND TABLE FROM THE SOURCE MATERIAL IS INCLUDED EXACTLY AS WRITTEN ‚Äì NO
            OMISSIONS.</p>

    </div>
</body>

</html>