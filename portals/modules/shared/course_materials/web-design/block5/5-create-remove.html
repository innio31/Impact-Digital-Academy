<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Creating and Removing DOM Elements Â· comprehensive guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background: #f0f4f8;
            color: #1a2b3c;
            line-height: 1.6;
            padding: 1.2rem;
        }

        .document-wrapper {
            max-width: 1300px;
            margin: 0 auto;
            background: white;
            border-radius: 2rem;
            box-shadow: 0 25px 45px -20px #0b2a3b;
            padding: 2rem 1.8rem;
        }

        h1 {
            font-size: clamp(2rem, 7vw, 3.6rem);
            background: linear-gradient(130deg, #1d4f6e, #b55a4a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0.2rem 0 0.5rem;
            border-left: 10px solid #c06551;
            padding-left: 1.2rem;
        }

        h2 {
            font-size: clamp(1.8rem, 5vw, 2.4rem);
            color: #1b4f6c;
            margin: 2rem 0 1rem;
            border-bottom: 3px solid #d68970;
            padding-bottom: 0.4rem;
        }

        h3 {
            font-size: clamp(1.4rem, 4vw, 1.9rem);
            color: #1d5777;
            margin: 1.8rem 0 0.8rem;
            background: #e7f0f9;
            padding: 0.4rem 1.2rem;
            border-radius: 40px;
            display: inline-block;
        }

        h4 {
            font-size: clamp(1.2rem, 3.5vw, 1.6rem);
            color: #215c7a;
            margin: 1.2rem 0 0.6rem;
        }

        p,
        li,
        td,
        .code-block,
        table {
            font-size: clamp(1rem, 2.5vw, 1.1rem);
        }

        .section-badge {
            background: #2f6584;
            color: white;
            padding: 0.2rem 2rem;
            border-radius: 50px;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: 600;
            display: inline-block;
            margin: 1rem 0;
        }

        pre {
            background: #1e2f3f;
            color: #e4f0fb;
            padding: 1.4rem;
            border-radius: 24px;
            overflow-x: auto;
            font-size: 0.95rem;
            line-height: 1.5;
            margin: 1.5rem 0;
            box-shadow: inset 0 0 0 1px #567e9c;
            white-space: pre-wrap;
            word-break: break-word;
        }

        code {
            background: #e0ecf7;
            color: #1b4057;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.95em;
            font-weight: 500;
        }

        pre code {
            background: transparent;
            color: inherit;
            padding: 0;
            border-radius: 0;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            border-radius: 1.5rem;
            overflow: hidden;
            box-shadow: 0 6px 16px rgba(28, 65, 92, 0.15);
        }

        th {
            background: #265f80;
            color: white;
            padding: 0.9rem 0.8rem;
            font-weight: 600;
        }

        td {
            padding: 0.8rem;
            border-bottom: 1px solid #c6dcee;
            background: #f9fdff;
        }

        .feature-compare {
            background: #e8f2fa;
            border-radius: 2rem;
            padding: 1.2rem;
            margin: 1.5rem 0;
            border-left: 8px solid #3a799b;
        }

        hr {
            border: none;
            height: 2px;
            background: linear-gradient(90deg, #cbdbe9, white, #cbdbe9);
            margin: 2rem 0;
        }

        .card-note {
            background: #f1f9ff;
            border-radius: 1.8rem;
            padding: 1.2rem 1.8rem;
            margin: 2rem 0;
            border: 1px solid #b6d0e3;
        }

        .badge {
            background: #1f5f80;
            color: white;
            padding: 0.2rem 1.2rem;
            border-radius: 40px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        footer {
            margin-top: 3rem;
            text-align: center;
            color: #2b5e7e;
            font-size: clamp(0.9rem, 2.8vw, 1rem);
            border-top: 2px dashed #abc0d1;
            padding-top: 1.5rem;
        }

        ul,
        ol {
            padding-left: 1.8rem;
            margin: 1rem 0;
        }

        li {
            margin: 0.4rem 0;
        }

        .grid-ref {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .ref-card {
            background: white;
            border-radius: 1.5rem;
            padding: 1rem;
            border: 1px solid #b8d2e7;
            box-shadow: 0 6px 12px #deecf6;
        }
    </style>
</head>

<body>
    <div class="document-wrapper">

        <!-- title exactly as given -->
        <h1>Creating and Removing DOM Elements</h1>
        <p style="font-size:1.4rem; color:#2b6f92;">A Comprehensive Guide to Dynamic Element Manipulation in JavaScript
        </p>
        <hr>

        <!-- PART 1: FOUNDATIONAL CONCEPTS (complete) -->
        <h2 id="part1">PART 1: FOUNDATIONAL CONCEPTS</h2>
        <h3>1.1 Understanding the DOM (Document Object Model)</h3>
        <p><strong>What is the DOM?</strong> The Document Object Model (DOM) is a programming interface for HTML and XML
            documents. It represents the page so that programs can change the document structure, style, and content.
            The DOM represents the document as a tree of objects.</p>
        <p><strong>Key Concepts:</strong></p>
        <ul>
            <li>The DOM is not JavaScript - it's a Web API that JavaScript can use</li>
            <li>Every element in your HTML becomes an object in the DOM tree</li>
            <li>The DOM is live - changes to it are immediately reflected in the browser</li>
            <li>The DOM is language-independent (can be accessed by any programming language)</li>
        </ul>
        <p><strong>Visual Representation of the DOM Tree</strong></p>
        <pre>                    window
                       |
                    document
                       |
                     &lt;html&gt;
                    /      \
                &lt;head&gt;    &lt;body&gt;
                /    \        |
            &lt;title&gt;  ...    &lt;div&gt;
                            /   \
                        &lt;h1&gt;   &lt;p&gt;</pre>
        <p><strong>The <code>document</code> Object</strong></p>
        <pre>console.log(document); // Shows the entire document object
console.log(document.body); // References the &lt;body&gt; element
console.log(document.head); // References the &lt;head&gt; element
console.log(document.documentElement); // References the &lt;html&gt; element</pre>

        <h3>1.2 Why Dynamic Element Creation?</h3>
        <p>Static HTML pages are limited. Dynamic element creation enables:</p>
        <ol>
            <li><strong>User-Driven Interfaces</strong>: Adding items to a to-do list, creating new posts, uploading
                files</li>
            <li><strong>Data Visualization</strong>: Generating charts, tables, and graphs from API data</li>
            <li><strong>Infinite Scrolling</strong>: Loading more content as the user scrolls</li>
            <li><strong>Single Page Applications (SPAs)</strong>: Updating content without page reloads</li>
            <li><strong>Form Enhancements</strong>: Adding dynamic form fields, removing options</li>
            <li><strong>Real-time Updates</strong>: Chat messages, notifications, live feeds</li>
        </ol>
        <hr>

        <!-- PART 2: createElement  -->
        <h2>PART 2: THE <code>createElement()</code> METHOD</h2>
        <h3>2.1 Syntax and Basic Usage</h3>
        <pre>const newElement = document.createElement(tagName);
const newElement = document.createElement(tagName, options);</pre>
        <p><strong>Parameters:</strong></p>
        <table>
            <tr>
                <th>Parameter</th>
                <th>Type</th>
                <th>Description</th>
                <th>Required?</th>
            </tr>
            <tr>
                <td><code>tagName</code></td>
                <td>String</td>
                <td>The name of the element to create (e.g., 'div', 'p', 'span')</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><code>options</code></td>
                <td>Object</td>
                <td>Optional settings (rarely used, mainly for custom elements)</td>
                <td>No</td>
            </tr>
        </table>
        <p><strong>Return Value:</strong> A new <code>Element</code> object representing the created element.</p>

        <h3>2.2 Creating Different Element Types</h3>
        <pre>// Creating various HTML elements
const div = document.createElement('div');
const paragraph = document.createElement('p');
const heading = document.createElement('h1');
const anchor = document.createElement('a');
const image = document.createElement('img');
const listItem = document.createElement('li');
const button = document.createElement('button');
const input = document.createElement('input');
const select = document.createElement('select');
const option = document.createElement('option');
const table = document.createElement('table');
const tableRow = document.createElement('tr');
const tableCell = document.createElement('td');
const form = document.createElement('form');
const span = document.createElement('span');
const section = document.createElement('section');
const article = document.createElement('article');
const nav = document.createElement('nav');
const header = document.createElement('header');
const footer = document.createElement('footer');</pre>

        <h3>2.3 What Happens When You Create an Element?</h3>
        <pre>// 1. Memory allocation, 2. Not in DOM yet, 3. No rendering, 4. Properties available
const newDiv = document.createElement('div');
console.log(newDiv); // &lt;div&gt;&lt;/div&gt; - exists in memory
console.log(document.body.contains(newDiv)); // false - not in DOM</pre>

        <h3>2.4 Creating Elements with Namespaces (Advanced)</h3>
        <pre>// Create an SVG element
const svgNS = "http://www.w3.org/2000/svg";
const svg = document.createElementNS(svgNS, "svg");
const circle = document.createElementNS(svgNS, "circle");
circle.setAttributeNS(null, "cx", 50);
circle.setAttributeNS(null, "cy", 50);
circle.setAttributeNS(null, "r", 40);

// Create a MathML element
const mathNS = "http://www.w3.org/1998/Math/MathML";
const math = document.createElementNS(mathNS, "math");</pre>
        <hr>

        <!-- PART 3: appendChild -->
        <h2>PART 3: APPENDING ELEMENTS WITH <code>appendChild()</code></h2>
        <h3>3.1 Syntax and Basic Usage</h3>
        <pre>const appendedNode = parentElement.appendChild(childElement);</pre>
        <p><strong>Parameters:</strong> <code>childElement</code>: The node to append to the parent.<br>
            <strong>Return Value:</strong> Returns the appended child node (the same node you passed in).<br>
            <strong>What <code>appendChild()</code> Does:</strong>
        </p>
        <ul>
            <li>Moves or Copies? If the child element already exists in the DOM, it is moved (not copied) to the new
                position.</li>
            <li>Parent-Child Relationship: Establishes a parent-child relationship in the DOM tree.</li>
            <li>Position: Always appends as the LAST child of the parent.</li>
            <li>Live Update: The DOM updates immediately, and the browser re-renders.</li>
        </ul>

        <h3>3.2 Complete Example: Building a Card Component</h3>
        <pre>// Step 1: Create the container
const card = document.createElement('div');
card.className = 'card';
card.style.border = '1px solid #ccc';
card.style.padding = '16px';
card.style.margin = '10px';
card.style.borderRadius = '8px';

// Step 2: Create and configure child elements
const title = document.createElement('h2');
title.textContent = 'Dynamic Card Title';
title.style.margin = '0 0 8px 0';
title.style.color = '#333';

const content = document.createElement('p');
content.textContent = 'This card was created dynamically with JavaScript!';
content.style.margin = '0 0 12px 0';
content.style.color = '#666';

const button = document.createElement('button');
button.textContent = 'Click Me';
button.style.padding = '8px 16px';
button.style.backgroundColor = '#007bff';
button.style.color = 'white';
button.style.border = 'none';
button.style.borderRadius = '4px';
button.style.cursor = 'pointer';

// Step 3: Add event listener to button
button.addEventListener('click', () => {
    alert('Button on dynamic card was clicked!');
});

// Step 4: Append all children to the card
card.appendChild(title);
card.appendChild(content);
card.appendChild(button);

// Step 5: Append the card to the body
document.body.appendChild(card);</pre>

        <h3>3.3 The Difference Between <code>appendChild()</code> and <code>append()</code></h3>
        <table>
            <tr>
                <th>Feature</th>
                <th><code>appendChild()</code></th>
                <th><code>append()</code></th>
            </tr>
            <tr>
                <td>Return value</td>
                <td>Returns the appended node</td>
                <td>Returns <code>undefined</code></td>
            </tr>
            <tr>
                <td>Can append text</td>
                <td>No (only nodes)</td>
                <td>Yes (can append text strings)</td>
            </tr>
            <tr>
                <td>Can append multiple items</td>
                <td>No (only one)</td>
                <td>Yes (multiple nodes/text)</td>
            </tr>
            <tr>
                <td>Browser support</td>
                <td>All browsers</td>
                <td>Modern browsers only</td>
            </tr>
            <tr>
                <td>Type</td>
                <td>Legacy method</td>
                <td>Modern method</td>
            </tr>
        </table>
        <pre>// Using appendChild (traditional)
const div = document.createElement('div');
div.appendChild(document.createTextNode('Hello'));
div.appendChild(document.createElement('span'));

// Using append (modern)
const div2 = document.createElement('div');
div2.append('Hello', document.createElement('span'));
// Can append multiple items at once!
div2.append('More text', document.createElement('hr'), 'Even more');</pre>

        <h3>3.4 Appending to Different Parent Elements</h3>
        <pre>// Appending to various parent elements
const container = document.getElementById('container');
const list = document.getElementById('myList');
const form = document.getElementById('myForm');
const table = document.getElementById('myTable');

// 1. Appending to a div container
const newParagraph = document.createElement('p');
newParagraph.textContent = 'New paragraph in container';
container.appendChild(newParagraph);

// 2. Appending to a list
const newListItem = document.createElement('li');
newListItem.textContent = 'New list item';
newListItem.style.fontWeight = 'bold';
list.appendChild(newListItem);

// 3. Appending to a form
const newInput = document.createElement('input');
newInput.type = 'text';
newInput.name = 'dynamicField';
newInput.placeholder = 'Dynamically added field';
form.appendChild(newInput);

// 4. Appending to a table
const newRow = document.createElement('tr');
const cell1 = document.createElement('td');
cell1.textContent = 'Row 1, Cell 1';
const cell2 = document.createElement('td');
cell2.textContent = 'Row 1, Cell 2';
newRow.appendChild(cell1);
newRow.appendChild(cell2);
table.appendChild(newRow);</pre>

        <h3>3.5 Complex Example: Building a Nested Structure</h3>
        <pre>// Creating a nested comment section dynamically
function createCommentSection() {
    // Main container
    const commentsSection = document.createElement('section');
    commentsSection.className = 'comments-section';
    commentsSection.style.maxWidth = '600px';
    commentsSection.style.margin = '20px auto';
    
    // Section title
    const title = document.createElement('h3');
    title.textContent = 'Comments (3)';
    title.style.borderBottom = '2px solid #eee';
    title.style.paddingBottom = '8px';
    commentsSection.appendChild(title);
    
    // Create multiple comments
    const comments = [
        { author: 'John Doe', text: 'Great article!', time: '2 hours ago' },
        { author: 'Jane Smith', text: 'Thanks for sharing this information', time: '5 hours ago' },
        { author: 'Bob Johnson', text: 'Very helpful, looking forward to more!', time: '1 day ago' }
    ];
    
    comments.forEach(comment => {
        // Create comment container
        const commentDiv = document.createElement('div');
        commentDiv.className = 'comment';
        commentDiv.style.backgroundColor = '#f9f9f9';
        commentDiv.style.padding = '12px';
        commentDiv.style.marginBottom = '10px';
        commentDiv.style.borderRadius = '4px';
        
        // Author header
        const headerDiv = document.createElement('div');
        headerDiv.style.display = 'flex';
        headerDiv.style.justifyContent = 'space-between';
        headerDiv.style.marginBottom = '6px';
        
        const authorSpan = document.createElement('span');
        authorSpan.textContent = comment.author;
        authorSpan.style.fontWeight = 'bold';
        
        const timeSpan = document.createElement('span');
        timeSpan.textContent = comment.time;
        timeSpan.style.color = '#999';
        timeSpan.style.fontSize = '0.9em';
        
        headerDiv.appendChild(authorSpan);
        headerDiv.appendChild(timeSpan);
        
        // Comment text
        const textP = document.createElement('p');
        textP.textContent = comment.text;
        textP.style.margin = '0';
        textP.style.lineHeight = '1.5';
        
        // Action buttons
        const actionsDiv = document.createElement('div');
        actionsDiv.style.marginTop = '8px';
        
        const replyBtn = document.createElement('button');
        replyBtn.textContent = 'Reply';
        replyBtn.style.marginRight = '10px';
        replyBtn.style.padding = '4px 12px';
        replyBtn.style.backgroundColor = 'transparent';
        replyBtn.style.border = '1px solid #007bff';
        replyBtn.style.color = '#007bff';
        replyBtn.style.borderRadius = '4px';
        replyBtn.style.cursor = 'pointer';
        
        const likeBtn = document.createElement('button');
        likeBtn.textContent = 'Like';
        likeBtn.style.padding = '4px 12px';
        likeBtn.style.backgroundColor = 'transparent';
        likeBtn.style.border = '1px solid #28a745';
        likeBtn.style.color = '#28a745';
        likeBtn.style.borderRadius = '4px';
        likeBtn.style.cursor = 'pointer';
        
        actionsDiv.appendChild(replyBtn);
        actionsDiv.appendChild(likeBtn);
        
        // Assemble everything
        commentDiv.appendChild(headerDiv);
        commentDiv.appendChild(textP);
        commentDiv.appendChild(actionsDiv);
        
        commentsSection.appendChild(commentDiv);
    });
    
    // Add new comment form
    const formDiv = document.createElement('div');
    formDiv.style.marginTop = '20px';
    
    const textarea = document.createElement('textarea');
    textarea.placeholder = 'Add a comment...';
    textarea.style.width = '100%';
    textarea.style.padding = '8px';
    textarea.style.marginBottom = '8px';
    textarea.rows = 3;
    
    const submitBtn = document.createElement('button');
    submitBtn.textContent = 'Post Comment';
    submitBtn.style.padding = '8px 16px';
    submitBtn.style.backgroundColor = '#007bff';
    submitBtn.style.color = 'white';
    submitBtn.style.border = 'none';
    submitBtn.style.borderRadius = '4px';
    submitBtn.style.cursor = 'pointer';
    
    formDiv.appendChild(textarea);
    formDiv.appendChild(submitBtn);
    commentsSection.appendChild(formDiv);
    
    return commentsSection;
}

// Use the function
document.body.appendChild(createCommentSection());</pre>
        <hr>

        <!-- PART 4: ADVANCED ELEMENT CONFIGURATION -->
        <h2>PART 4: ADVANCED ELEMENT CONFIGURATION</h2>
        <h3>4.1 Setting Attributes</h3>
        <pre>const element = document.createElement('div');

// Method 1: setAttribute()
element.setAttribute('id', 'myDynamicId');
element.setAttribute('class', 'dynamic-class');
element.setAttribute('data-custom', 'custom-value');
element.setAttribute('aria-label', 'Dynamic element');

// Method 2: Direct property access (preferred for standard properties)
element.id = 'myDynamicId';
element.className = 'dynamic-class';
element.title = 'Tooltip text';
element.tabIndex = 0;

// Method 3: For specific element types
const img = document.createElement('img');
img.src = 'image.jpg';
img.alt = 'Description';
img.width = 300;
img.height = 200;

const input = document.createElement('input');
input.type = 'checkbox';
input.name = 'agreement';
input.checked = true; // Checked by default
input.value = 'yes';
input.disabled = false;
input.required = true;
input.placeholder = 'Enter text';</pre>

        <h3>4.2 Setting Styles</h3>
        <pre>const element = document.createElement('div');

// Method 1: Direct style property (camelCase)
element.style.backgroundColor = '#f0f0f0';
element.style.fontSize = '16px';
element.style.marginTop = '10px';
element.style.borderRadius = '4px';
element.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
element.style.display = 'flex';
element.style.justifyContent = 'center';
element.style.alignItems = 'center';
element.style.transition = 'all 0.3s ease';

// Method 2: Using setAttribute (kebab-case)
element.setAttribute('style', 'background-color: blue; color: white; padding: 10px;');

// Method 3: Adding CSS classes (best practice)
element.className = 'card card-primary';
element.classList.add('highlight', 'border');
element.classList.remove('old-class');
element.classList.toggle('active');</pre>

        <h3>4.3 Setting Content</h3>
        <pre>const element = document.createElement('div');

// Method 1: textContent (safe, treats as text)
element.textContent = '&lt;strong&gt;This is not bold, it\'s text&lt;/strong&gt;';
// Result: &lt;div&gt;&amp;lt;strong&amp;gt;This is not bold, it's text&amp;lt;/strong&amp;gt;&lt;/div&gt;

// Method 2: innerHTML (dangerous, parses HTML)
element.innerHTML = '&lt;strong&gt;This is bold text&lt;/strong&gt;';
// Result: &lt;div&gt;&lt;strong&gt;This is bold text&lt;/strong&gt;&lt;/div&gt;

// Method 3: createTextNode (safest for text only)
const textNode = document.createTextNode('This is plain text');
element.appendChild(textNode);

// Method 4: innerText (similar to textContent but aware of styling)
element.innerText = 'This respects CSS styling';</pre>

        <h4>Security Warning: innerHTML Dangers</h4>
        <pre>// DANGEROUS - XSS vulnerability
const userInput = '&lt;img src="x" onerror="alert(\'Hacked!\')"&gt;';
element.innerHTML = userInput; // This would execute malicious code!

// SAFE - Use textContent instead
element.textContent = userInput; // Shows the code as text, doesn't execute

// SAFE alternative if you need HTML
const safeElement = document.createElement('div');
safeElement.textContent = 'Part that needs to be safe';
const boldPart = document.createElement('strong');
boldPart.textContent = userInput; // Still safe!
safeElement.appendChild(boldPart);</pre>

        <h3>4.4 Working with Data Attributes</h3>
        <pre>const element = document.createElement('div');

// Setting data attributes
element.dataset.id = '12345';
element.dataset.userRole = 'admin';
element.dataset.lastUpdated = '2024-01-15';
element.dataset.viewCount = '0';

// Equivalent to:
// &lt;div data-id="12345" data-user-role="admin" 
//      data-last-updated="2024-01-15" data-view-count="0"&gt;&lt;/div&gt;

// Reading data attributes
console.log(element.dataset.id); // '12345'
console.log(element.dataset.userRole); // 'admin'
console.log(element.dataset.viewCount); // '0'

// Using data attributes for dynamic behavior
element.addEventListener('click', function(e) {
    const count = parseInt(this.dataset.viewCount) + 1;
    this.dataset.viewCount = count;
    this.textContent = `Clicked ${count} times`;
});</pre>
        <hr>

        <!-- PART 5: REMOVING ELEMENTS WITH removeChild -->
        <h2>PART 5: REMOVING ELEMENTS WITH <code>removeChild()</code></h2>
        <h3>5.1 Syntax and Basic Usage</h3>
        <pre>const removedNode = parentElement.removeChild(childElement);</pre>
        <p><strong>Parameters:</strong> <code>childElement</code>: The node to remove from the parent.<br>
            <strong>Return Value:</strong> Returns the removed node (which still exists in memory).<br>
            <strong>Important Notes:</strong> The removed node can be reinserted elsewhere. Throws an error if the child
            is not a child of the parent. The browser updates the display immediately.
        </p>

        <h3>5.2 Basic Examples of Removal</h3>
        <pre>// Remove an element by reference
const elementToRemove = document.getElementById('toBeRemoved');
elementToRemove.parentNode.removeChild(elementToRemove);

// Remove the last child of an element
const container = document.getElementById('container');
if (container.hasChildNodes()) {
    const lastChild = container.lastChild;
    container.removeChild(lastChild);
}

// Remove all children
function removeAllChildren(parent) {
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }
}

const list = document.getElementById('myList');
removeAllChildren(list);</pre>

        <h3>5.3 The Relationship Between <code>removeChild()</code> and <code>remove()</code></h3>
        <table>
            <tr>
                <th>Feature</th>
                <th><code>removeChild()</code></th>
                <th><code>remove()</code></th>
            </tr>
            <tr>
                <td>Syntax</td>
                <td><code>parent.removeChild(child)</code></td>
                <td><code>element.remove()</code></td>
            </tr>
            <tr>
                <td>Return value</td>
                <td>Returns removed node</td>
                <td>Returns <code>undefined</code></td>
            </tr>
            <tr>
                <td>Need parent reference</td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td>Browser support</td>
                <td>All browsers</td>
                <td>Modern browsers only</td>
            </tr>
            <tr>
                <td>Can reinsert removed node</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
        </table>
        <pre>// Traditional method (older browsers)
const parent = document.getElementById('parent');
const child = document.getElementById('child');
parent.removeChild(child);

// Modern method (simpler)
child.remove();

// You can still reinsert it
document.body.appendChild(child); // Works with both methods</pre>

        <h3>5.4 Conditional Removal Examples</h3>
        <pre>// Remove elements based on content
function removeItemsContainingText(container, text) {
    const items = container.children;
    for (let i = items.length - 1; i >= 0; i--) { // Loop backwards!
        const item = items[i];
        if (item.textContent.includes(text)) {
            item.remove(); // Using modern method
            // container.removeChild(item); // Using traditional method
        }
    }
}

// Remove elements based on class
function removeElementsByClass(className) {
    const elements = document.getElementsByClassName(className);
    while (elements.length > 0) { // Live collection updates!
        elements[0].remove();
    }
}

// Remove elements based on attribute
function removeElementsWithAttribute(attrName) {
    const elements = document.querySelectorAll(`[${attrName}]`);
    elements.forEach(element => element.remove());
}</pre>

        <h3>5.5 Complete Example: Dynamic List Manager</h3>
        <pre>// Create a dynamic list with add and remove functionality
function createDynamicList() {
    // Create container
    const container = document.createElement('div');
    container.style.maxWidth = '400px';
    container.style.margin = '20px auto';
    container.style.padding = '20px';
    container.style.border = '1px solid #ccc';
    container.style.borderRadius = '8px';
    
    // Title
    const title = document.createElement('h2');
    title.textContent = 'Dynamic Task List';
    title.style.margin = '0 0 20px 0';
    container.appendChild(title);
    
    // Input area
    const inputGroup = document.createElement('div');
    inputGroup.style.display = 'flex';
    inputGroup.style.marginBottom = '20px';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Enter a new task...';
    input.style.flex = '1';
    input.style.padding = '8px';
    input.style.marginRight = '8px';
    input.style.border = '1px solid #ccc';
    input.style.borderRadius = '4px';
    
    const addButton = document.createElement('button');
    addButton.textContent = 'Add Task';
    addButton.style.padding = '8px 16px';
    addButton.style.backgroundColor = '#28a745';
    addButton.style.color = 'white';
    addButton.style.border = 'none';
    addButton.style.borderRadius = '4px';
    addButton.style.cursor = 'pointer';
    
    inputGroup.appendChild(input);
    inputGroup.appendChild(addButton);
    container.appendChild(inputGroup);
    
    // List container
    const listContainer = document.createElement('div');
    listContainer.id = 'taskList';
    
    // Add task function
    function addTask() {
        const taskText = input.value.trim();
        if (!taskText) {
            alert('Please enter a task');
            return;
        }
        
        // Create task item
        const taskItem = document.createElement('div');
        taskItem.style.display = 'flex';
        taskItem.style.justifyContent = 'space-between';
        taskItem.style.alignItems = 'center';
        taskItem.style.padding = '10px';
        taskItem.style.marginBottom = '8px';
        taskItem.style.backgroundColor = '#f8f9fa';
        taskItem.style.border = '1px solid #dee2e6';
        taskItem.style.borderRadius = '4px';
        
        // Task text
        const textSpan = document.createElement('span');
        textSpan.textContent = taskText;
        
        // Complete checkbox
        const completeCheckbox = document.createElement('input');
        completeCheckbox.type = 'checkbox';
        completeCheckbox.style.marginRight = '10px';
        completeCheckbox.addEventListener('change', function() {
            if (this.checked) {
                taskItem.style.backgroundColor = '#d4edda';
                textSpan.style.textDecoration = 'line-through';
                textSpan.style.color = '#6c757d';
            } else {
                taskItem.style.backgroundColor = '#f8f9fa';
                textSpan.style.textDecoration = 'none';
                textSpan.style.color = '#212529';
            }
        });
        
        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Delete';
        removeBtn.style.padding = '4px 8px';
        removeBtn.style.backgroundColor = '#dc3545';
        removeBtn.style.color = 'white';
        removeBtn.style.border = 'none';
        removeBtn.style.borderRadius = '4px';
        removeBtn.style.cursor = 'pointer';
        
        // Remove functionality
        removeBtn.addEventListener('click', function() {
            // Ask for confirmation
            if (confirm('Delete this task?')) {
                // Method 1: Using remove()
                taskItem.remove();
                
                // Alternative Method 2: Using removeChild()
                // listContainer.removeChild(taskItem);
            }
        });
        
        // Assemble task item
        const leftDiv = document.createElement('div');
        leftDiv.appendChild(completeCheckbox);
        leftDiv.appendChild(textSpan);
        
        taskItem.appendChild(leftDiv);
        taskItem.appendChild(removeBtn);
        
        // Add to list
        listContainer.appendChild(taskItem);
        
        // Clear input
        input.value = '';
    }
    
    // Event listeners
    addButton.addEventListener('click', addTask);
    input.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            addTask();
        }
    });
    
    container.appendChild(listContainer);
    
    // Add "Clear All" button
    const clearAllBtn = document.createElement('button');
    clearAllBtn.textContent = 'Clear All Tasks';
    clearAllBtn.style.marginTop = '10px';
    clearAllBtn.style.padding = '8px 16px';
    clearAllBtn.style.backgroundColor = '#6c757d';
    clearAllBtn.style.color = 'white';
    clearAllBtn.style.border = 'none';
    clearAllBtn.style.borderRadius = '4px';
    clearAllBtn.style.cursor = 'pointer';
    
    clearAllBtn.addEventListener('click', function() {
        if (confirm('Delete ALL tasks?')) {
            // Remove all children from listContainer
            while (listContainer.firstChild) {
                listContainer.removeChild(listContainer.firstChild);
            }
        }
    });
    
    container.appendChild(clearAllBtn);
    
    return container;
}

// Add the dynamic list to the page
document.body.appendChild(createDynamicList());</pre>
        <hr>

        <!-- PART 6: LIFECYCLE AND MEMORY -->
        <h2>PART 6: ELEMENT LIFECYCLE AND MEMORY MANAGEMENT</h2>
        <h3>6.1 What Happens When You Create Elements?</h3>
        <pre>// Stage 1: Creation (in memory only)
const element = document.createElement('div');
// Element exists but is not visible, not in the DOM tree

// Stage 2: Configuration
element.textContent = 'Hello';
element.className = 'greeting';
// Element is still in memory only, but fully configured

// Stage 3: Insertion
document.body.appendChild(element);
// Element becomes part of the DOM, visible to user
// Browser recalculates layout (reflow) and repaints

// Stage 4: Manipulation
element.textContent = 'Updated!';
// Browser may need to repaint

// Stage 5: Removal
element.remove();
// Element removed from DOM, no longer visible
// Element still exists in memory if referenced

// Stage 6: Garbage Collection
element = null;
// If no other references exist, element can be garbage collected</pre>

        <h3>6.2 Memory Leaks and Prevention</h3>
        <pre>// LEAK EXAMPLE 1: Global references
function createLeak() {
    leakedElement = document.createElement('div'); // No var/let/const!
    document.body.appendChild(leakedElement);
}
// leakedElement is global and cannot be garbage collected

// LEAK EXAMPLE 2: Detached DOM elements
const detachedElements = [];
function createDetached() {
    const element = document.createElement('div');
    detachedElements.push(element); // Storing reference
    document.body.appendChild(element);
}
// Even after removal from DOM, elements remain in array

// LEAK EXAMPLE 3: Event listeners
function leakyButton() {
    const button = document.createElement('button');
    button.textContent = 'Click';
    
    // This listener creates a closure referencing button
    button.addEventListener('click', function() {
        console.log(button.textContent); // Closure reference!
    });
    
    document.body.appendChild(button);
    // Even if button removed, listener prevents garbage collection
}

// PROPER CLEANUP
function properCleanup() {
    const button = document.createElement('button');
    
    // Named function for removal
    function handler() {
        console.log('Clicked');
    }
    
    button.addEventListener('click', handler);
    document.body.appendChild(button);
    
    // Later, when removing:
    button.removeEventListener('click', handler);
    button.remove();
}</pre>

        <h3>6.3 Reusing Removed Elements</h3>
        <pre>// Elements removed from DOM still exist and can be reused
function demonstrateReuse() {
    // Create and configure
    const specialElement = document.createElement('div');
    specialElement.textContent = 'I am special!';
    specialElement.style.color = 'blue';
    specialElement.style.fontWeight = 'bold';
    
    // Append to container A
    const containerA = document.getElementById('containerA');
    containerA.appendChild(specialElement);
    
    // Later, move to container B
    setTimeout(() => {
        const containerB = document.getElementById('containerB');
        
        // Remove from A
        containerA.removeChild(specialElement);
        
        // All styles and content are preserved!
        containerB.appendChild(specialElement);
        
        // Modify if needed
        specialElement.style.color = 'red';
    }, 2000);
    
    // Can also clone instead of move
    const clone = specialElement.cloneNode(true); // true = deep clone
    document.body.appendChild(clone);
}</pre>
        <hr>

        <!-- PART 7: ADVANCED TECHNIQUES -->
        <h2>PART 7: ADVANCED TECHNIQUES AND PATTERNS</h2>
        <h3>7.1 Document Fragments for Performance</h3>
        <pre>// INEFFICIENT - Causes multiple reflows
function inefficientAdd() {
    const list = document.getElementById('myList');
    for (let i = 0; i < 1000; i++) {
        const li = document.createElement('li');
        li.textContent = `Item ${i}`;
        list.appendChild(li); // 1000 reflows!
    }
}

// EFFICIENT - Using DocumentFragment
function efficientAdd() {
    const list = document.getElementById('myList');
    const fragment = document.createDocumentFragment();
    
    for (let i = 0; i < 1000; i++) {
        const li = document.createElement('li');
        li.textContent = `Item ${i}`;
        fragment.appendChild(li); // No reflow
    }
    
    list.appendChild(fragment); // ONE reflow!
    console.log(fragment.children.length); // 0 (fragment is empty now)
}

// DocumentFragment is like a lightweight document
const fragment = document.createDocumentFragment();
console.log(fragment.nodeType); // 11 (DocumentFragment)
console.log(fragment instanceof DocumentFragment); // true

// You can query fragment contents
fragment.querySelectorAll('li'); // Works!</pre>

        <h3>7.2 Template Element for Reusable Structures</h3>
        <pre>// HTML template (can be in HTML or created dynamically)
const templateHTML = `
    &lt;div class="user-card"&gt;
        &lt;img class="avatar" src="" alt="User avatar"&gt;
        &lt;div class="user-info"&gt;
            &lt;h3 class="user-name"&gt;&lt;/h3&gt;
            &lt;p class="user-email"&gt;&lt;/p&gt;
            &lt;span class="user-role"&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;button class="edit-btn"&gt;Edit&lt;/button&gt;
    &lt;/div&gt;
`;

// Method 1: Using &lt;template&gt; element (best)
function createFromTemplate() {
    // Create template element
    const template = document.createElement('template');
    template.innerHTML = templateHTML;
    
    // Clone the content
    const userCard = template.content.cloneNode(true); // true is important!
    
    // Now populate the cloned content
    const img = userCard.querySelector('.avatar');
    img.src = 'user.jpg';
    
    const name = userCard.querySelector('.user-name');
    name.textContent = 'John Doe';
    
    const email = userCard.querySelector('.user-email');
    email.textContent = 'john@example.com';
    
    return userCard;
}

// Method 2: Using string and innerHTML (careful with XSS)
function createFromString() {
    const container = document.createElement('div');
    container.innerHTML = templateHTML;
    return container.firstChild;
}

// Using the template multiple times
document.body.appendChild(createFromTemplate());
document.body.appendChild(createFromTemplate()); // Fresh copy each time</pre>

        <h3>7.3 Factory Pattern for Element Creation</h3>
        <pre>// Element factory - reusable function for creating elements
const ElementFactory = {
    createCard(title, content, type = 'info') {
        const card = document.createElement('div');
        card.className = `card card-${type}`;
        card.style.border = '1px solid #ddd';
        card.style.borderRadius = '8px';
        card.style.padding = '16px';
        card.style.margin = '10px';
        
        // Type-specific styling
        switch(type) {
            case 'warning':
                card.style.borderLeft = '4px solid #ffc107';
                card.style.backgroundColor = '#fff3cd';
                break;
            case 'error':
                card.style.borderLeft = '4px solid #dc3545';
                card.style.backgroundColor = '#f8d7da';
                break;
            case 'success':
                card.style.borderLeft = '4px solid #28a745';
                card.style.backgroundColor = '#d4edda';
                break;
            default: // info
                card.style.borderLeft = '4px solid #17a2b8';
                card.style.backgroundColor = '#d1ecf1';
        }
        
        const titleEl = document.createElement('h3');
        titleEl.textContent = title;
        titleEl.style.margin = '0 0 8px 0';
        
        const contentEl = document.createElement('p');
        contentEl.textContent = content;
        contentEl.style.margin = '0';
        contentEl.style.color = '#333';
        
        card.appendChild(titleEl);
        card.appendChild(contentEl);
        
        return card;
    },
    
    createButton(text, onClick, variant = 'primary') {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.padding = '8px 16px';
        button.style.border = 'none';
        button.style.borderRadius = '4px';
        button.style.cursor = 'pointer';
        
        // Variant styling
        switch(variant) {
            case 'primary':
                button.style.backgroundColor = '#007bff';
                button.style.color = 'white';
                break;
            case 'secondary':
                button.style.backgroundColor = '#6c757d';
                button.style.color = 'white';
                break;
            case 'outline':
                button.style.backgroundColor = 'transparent';
                button.style.border = '1px solid #007bff';
                button.style.color = '#007bff';
                break;
        }
        
        if (onClick) {
            button.addEventListener('click', onClick);
        }
        
        return button;
    },
    
    createInput(type = 'text', placeholder = '', value = '') {
        const input = document.createElement('input');
        input.type = type;
        input.placeholder = placeholder;
        input.value = value;
        input.style.padding = '8px';
        input.style.border = '1px solid #ccc';
        input.style.borderRadius = '4px';
        input.style.fontSize = '14px';
        
        return input;
    }
};

// Usage
const card1 = ElementFactory.createCard('Warning!', 'This action cannot be undone', 'warning');
const card2 = ElementFactory.createCard('Success!', 'Your changes were saved', 'success');

const button = ElementFactory.createButton('Click Me', () => alert('Clicked!'), 'primary');
const input = ElementFactory.createInput('email', 'Enter your email');

document.body.appendChild(card1);
document.body.appendChild(card2);
document.body.appendChild(button);
document.body.appendChild(input);</pre>

        <h3>7.4 Batch Operations and Virtual DOM Concepts</h3>
        <pre>// Simple implementation of Virtual DOM concept
class VirtualDOM {
    constructor() {
        this.elements = new Map();
    }
    
    createElement(tag, props = {}, children = []) {
        return { tag, props, children };
    }
    
    render(virtualElement) {
        const element = document.createElement(virtualElement.tag);
        
        // Set properties
        Object.entries(virtualElement.props).forEach(([key, value]) => {
            if (key.startsWith('on') && typeof value === 'function') {
                element.addEventListener(key.slice(2).toLowerCase(), value);
            } else if (key === 'className') {
                element.className = value;
            } else if (key === 'style' && typeof value === 'object') {
                Object.assign(element.style, value);
            } else {
                element.setAttribute(key, value);
            }
        });
        
        // Render children
        virtualElement.children.forEach(child => {
            if (typeof child === 'string') {
                element.appendChild(document.createTextNode(child));
            } else {
                element.appendChild(this.render(child));
            }
        });
        
        return element;
    }
    
    batchUpdate(updates) {
        const fragment = document.createDocumentFragment();
        updates.forEach(update => {
            const element = this.render(update.element);
            fragment.appendChild(element);
        });
        return fragment;
    }
}

// Usage
const vdom = new VirtualDOM();

const virtualButton = vdom.createElement('button', {
    className: 'btn-primary',
    style: { backgroundColor: 'blue', color: 'white' },
    onClick: () => alert('Clicked!')
}, ['Click me']);

const button = vdom.render(virtualButton);
document.body.appendChild(button);

// Batch update
const updates = [
    vdom.createElement('div', { className: 'card' }, ['Card 1']),
    vdom.createElement('div', { className: 'card' }, ['Card 2']),
    vdom.createElement('div', { className: 'card' }, ['Card 3'])
];

const fragment = vdom.batchUpdate(updates);
document.body.appendChild(fragment);</pre>
        <hr>

        <!-- PART 8: ERROR HANDLING AND BEST PRACTICES -->
        <h2>PART 8: ERROR HANDLING AND BEST PRACTICES</h2>
        <h3>8.1 Common Errors and Solutions</h3>
        <pre>// ERROR 1: Appending to non-existent parent
try {
    const parent = document.getElementById('nonExistent');
    parent.appendChild(document.createElement('div')); // Throws error!
} catch (error) {
    console.error('Parent element not found:', error);
}

// Solution: Check existence
const parent = document.getElementById('container');
if (parent) {
    parent.appendChild(document.createElement('div'));
} else {
    console.warn('Container not found, creating fallback');
    document.body.appendChild(document.createElement('div'));
}

// ERROR 2: Removing non-child
const child = document.createElement('div');
const wrongParent = document.createElement('div');
const actualParent = document.createElement('div');
actualParent.appendChild(child);

try {
    wrongParent.removeChild(child); // Throws error! (not a child of wrongParent)
} catch (error) {
    console.error('Cannot remove child from wrong parent:', error);
}

// Solution: Always remove from actual parent
if (child.parentNode === actualParent) {
    actualParent.removeChild(child);
}

// OR use child.remove() which doesn't need parent reference
child.remove();

// ERROR 3: Creating invalid elements
try {
    const invalid = document.createElement(''); // Empty string is invalid
} catch (error) {
    console.error('Invalid tag name:', error);
}

// Solution: Validate tag names
const validTags = ['div', 'span', 'p', 'h1', 'h2', 'h3', 'ul', 'li', 'table'];
function safeCreateElement(tagName) {
    if (!tagName || typeof tagName !== 'string') {
        throw new Error('Tag name must be a non-empty string');
    }
    
    // Optional: Restrict to valid HTML tags
    // if (!validTags.includes(tagName)) {
    //     throw new Error(`Invalid tag name: ${tagName}`);
    // }
    
    return document.createElement(tagName);
}</pre>

        <h3>8.2 Performance Best Practices</h3>
        <pre>// BAD: Multiple reflows
function badPerformance() {
    const container = document.getElementById('container');
    for (let i = 0; i < 100; i++) {
        const div = document.createElement('div');
        div.textContent = `Item ${i}`;
        div.style.backgroundColor = '#f0f0f0'; // Causes style recalculation
        div.style.padding = '5px'; // Another recalculation
        div.addEventListener('click', () => console.log(i)); // New listener each time
        container.appendChild(div); // Reflow
    }
}

// GOOD: Batch operations
function goodPerformance() {
    const container = document.getElementById('container');
    const fragment = document.createDocumentFragment();
    
    for (let i = 0; i < 100; i++) {
        const div = document.createElement('div');
        div.textContent = `Item ${i}`;
        
        // Apply all styles at once
        div.style.cssText = 'background-color: #f0f0f0; padding: 5px; margin: 2px;';
        
        // Use event delegation instead of individual listeners
        div.dataset.index = i;
        
        fragment.appendChild(div);
    }
    
    // Add single event listener to container (event delegation)
    container.addEventListener('click', (e) => {
        if (e.target.dataset.index) {
            console.log('Clicked item:', e.target.dataset.index);
        }
    });
    
    container.appendChild(fragment); // Single reflow
}

// GOOD: Use CSS classes instead of inline styles
const style = document.createElement('style');
style.textContent = `
    .dynamic-item {
        background-color: #f0f0f0;
        padding: 5px;
        margin: 2px;
        transition: all 0.3s ease;
    }
    .dynamic-item:hover {
        background-color: #e0e0e0;
    }
`;
document.head.appendChild(style);

function evenBetterPerformance() {
    const container = document.getElementById('container');
    const fragment = document.createDocumentFragment();
    
    for (let i = 0; i < 100; i++) {
        const div = document.createElement('div');
        div.className = 'dynamic-item'; // Single class instead of multiple styles
        div.textContent = `Item ${i}`;
        fragment.appendChild(div);
    }
    
    container.appendChild(fragment);
}</pre>

        <h3>8.3 Accessibility Best Practices</h3>
        <pre>function createAccessibleElement() {
    const button = document.createElement('button');
    button.textContent = 'Submit';
    
    // 1. Always provide alt text for images
    const img = document.createElement('img');
    img.src = 'icon.png';
    img.alt = 'Submit form'; // Descriptive alt text
    
    // 2. Use ARIA attributes when necessary
    const modal = document.createElement('div');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-labelledby', 'modal-title');
    modal.setAttribute('aria-describedby', 'modal-desc');
    
    const title = document.createElement('h2');
    title.id = 'modal-title';
    title.textContent = 'Confirm Action';
    
    const desc = document.createElement('p');
    desc.id = 'modal-desc';
    desc.textContent = 'Are you sure you want to delete this item?';
    
    modal.appendChild(title);
    modal.appendChild(desc);
    
    // 3. Ensure keyboard navigation
    const focusableButton = document.createElement('button');
    focusableButton.textContent = 'Focus me';
    focusableButton.tabIndex = 0; // Explicitly focusable (already is for buttons)
    
    const focusableDiv = document.createElement('div');
    focusableDiv.setAttribute('role', 'button'); // Tell screen readers it's a button
    focusableDiv.tabIndex = 0; // Make focusable
    focusableDiv.textContent = 'Custom button';
    focusableDiv.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            // Handle click
        }
    });
    
    // 4. Use semantic HTML when possible
    const nav = document.createElement('nav'); // Better than &lt;div role="navigation"&gt;
    const header = document.createElement('header'); // Better than &lt;div role="banner"&gt;
    const main = document.createElement('main'); // Better than &lt;div role="main"&gt;
    
    return { button, img, modal, focusableButton, focusableDiv };
}</pre>

        <h3>8.4 Testing Element Creation and Removal</h3>
        <pre>// Simple testing framework for DOM manipulation
class DOMTest {
    constructor() {
        this.tests = [];
        this.passed = 0;
        this.failed = 0;
    }
    
    test(name, fn) {
        try {
            fn();
            console.log(`â PASS: ${name}`);
            this.passed++;
        } catch (error) {
            console.error(`â FAIL: ${name}`);
            console.error(`   Error: ${error.message}`);
            this.failed++;
        }
    }
    
    assertElementCreated(parent, child) {
        if (!parent.contains(child)) {
            throw new Error('Element was not appended to parent');
        }
    }
    
    assertElementRemoved(parent, child) {
        if (parent.contains(child)) {
            throw new Error('Element was not removed from parent');
        }
    }
    
    assertHasClass(element, className) {
        if (!element.classList.contains(className)) {
            throw new Error(`Element missing class: ${className}`);
        }
    }
    
    summary() {
        console.log(`\nTest Summary: ${this.passed} passed, ${this.failed} failed`);
    }
}

// Run tests
const test = new DOMTest();

// Test element creation
test.test('createElement should create element with correct tag', () => {
    const div = document.createElement('div');
    if (div.tagName !== 'DIV') {
        throw new Error(`Expected DIV, got ${div.tagName}`);
    }
});

// Test appending
test.test('appendChild should add element to parent', () => {
    const parent = document.createElement('div');
    const child = document.createElement('span');
    parent.appendChild(child);
    test.assertElementCreated(parent, child);
});

// Test removal
test.test('removeChild should remove element from parent', () => {
    const parent = document.createElement('div');
    const child = document.createElement('span');
    parent.appendChild(child);
    parent.removeChild(child);
    test.assertElementRemoved(parent, child);
});

// Test class manipulation
test.test('classList should add classes correctly', () => {
    const element = document.createElement('div');
    element.classList.add('test-class', 'another-class');
    test.assertHasClass(element, 'test-class');
    test.assertHasClass(element, 'another-class');
});

test.summary();</pre>
        <hr>

        <!-- PART 9: REAL-WORLD APPLICATIONS -->
        <h2>PART 9: REAL-WORLD APPLICATIONS</h2>
        <h3>9.1 Building a Modal/Dialog System</h3>
        <pre>class ModalSystem {
    constructor() {
        this.modals = new Map();
        this.activeModal = null;
        this.createModalContainer();
    }
    
    createModalContainer() {
        // Create modal container if it doesn't exist
        if (!document.getElementById('modal-container')) {
            this.container = document.createElement('div');
            this.container.id = 'modal-container';
            this.container.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1000;
            `;
            document.body.appendChild(this.container);
        } else {
            this.container = document.getElementById('modal-container');
        }
    }
    
    createModal(id, options = {}) {
        const {
            title = 'Modal Title',
            content = '',
            width = '400px',
            closeOnOverlayClick = true,
            showCloseButton = true
        } = options;
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        `;
        
        // Create modal content
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.cssText = `
            background-color: white;
            border-radius: 8px;
            width: ${width};
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        `;
        
        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            padding: 16px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        `;
        
        const titleEl = document.createElement('h3');
        titleEl.textContent = title;
        titleEl.style.margin = '0';
        titleEl.style.fontSize = '18px';
        
        if (showCloseButton) {
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.cssText = `
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                padding: 0 8px;
                color: #999;
            `;
            closeBtn.addEventListener('click', () => this.closeModal(id));
            header.appendChild(closeBtn);
        }
        
        header.insertBefore(titleEl, header.firstChild);
        
        // Body
        const body = document.createElement('div');
        body.style.cssText = `
            padding: 20px;
        `;
        
        if (typeof content === 'string') {
            body.innerHTML = content;
        } else if (content instanceof HTMLElement) {
            body.appendChild(content);
        }
        
        // Footer (optional)
        const footer = document.createElement('div');
        footer.style.cssText = `
            padding: 16px 20px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        `;
        
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.style.cssText = `
            padding: 8px 16px;
            border: 1px solid #ccc;
            background-color: white;
            border-radius: 4px;
            cursor: pointer;
        `;
        cancelBtn.addEventListener('click', () => this.closeModal(id));
        
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = 'Confirm';
        confirmBtn.style.cssText = `
            padding: 8px 16px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        `;
        confirmBtn.addEventListener('click', () => {
            if (options.onConfirm) options.onConfirm();
            this.closeModal(id);
        });
        
        footer.appendChild(cancelBtn);
        footer.appendChild(confirmBtn);
        
        // Assemble
        modal.appendChild(header);
        modal.appendChild(body);
        modal.appendChild(footer);
        overlay.appendChild(modal);
        
        // Event listeners
        if (closeOnOverlayClick) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    this.closeModal(id);
                }
            });
        }
        
        // Store modal
        this.modals.set(id, {
            overlay,
            modal,
            options
        });
        
        return overlay;
    }
    
    openModal(id) {
        const modalData = this.modals.get(id);
        if (!modalData) return;
        
        const { overlay } = modalData;
        
        // Close any open modal
        if (this.activeModal) {
            this.closeModal(this.activeModal);
        }
        
        // Add to container and animate
        this.container.appendChild(overlay);
        
        // Force reflow for animation
        overlay.offsetHeight;
        
        overlay.style.pointerEvents = 'auto';
        overlay.style.opacity = '1';
        modalData.modal.style.transform = 'scale(1)';
        
        this.activeModal = id;
    }
    
    closeModal(id) {
        const modalData = this.modals.get(id);
        if (!modalData) return;
        
        const { overlay } = modalData;
        
        overlay.style.opacity = '0';
        modalData.modal.style.transform = 'scale(0.9)';
        overlay.style.pointerEvents = 'none';
        
        // Remove after animation
        setTimeout(() => {
            if (overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }, 300);
        
        if (this.activeModal === id) {
            this.activeModal = null;
        }
    }
    
    destroyModal(id) {
        this.closeModal(id);
        this.modals.delete(id);
    }
}

// Usage
const modalSystem = new ModalSystem();

// Create a modal
const modalContent = document.createElement('div');
modalContent.innerHTML = '&lt;p&gt;This is a dynamically created modal!&lt;/p&gt;';

modalSystem.createModal('example', {
    title: 'Dynamic Modal',
    content: modalContent,
    width: '500px',
    onConfirm: () => console.log('Confirmed!')
});

// Open it with a button
const openBtn = document.createElement('button');
openBtn.textContent = 'Open Modal';
openBtn.addEventListener('click', () => modalSystem.openModal('example'));
document.body.appendChild(openBtn);</pre>

        <h3>9.2 Infinite Scroll Implementation</h3>
        <pre>class InfiniteScroll {
    constructor(containerId, options = {}) {
        this.container = document.getElementById(containerId);
        this.options = {
            itemsPerPage: 20,
            threshold: 100,
            loadingHTML: '&lt;div class="loader"&gt;Loading...&lt;/div&gt;',
            ...options
        };
        
        this.page = 1;
        this.loading = false;
        this.hasMore = true;
        this.observer = null;
        
        this.init();
    }
    
    init() {
        // Create sentinel element
        this.sentinel = document.createElement('div');
        this.sentinel.className = 'scroll-sentinel';
        this.sentinel.style.height = '1px';
        this.container.appendChild(this.sentinel);
        
        // Setup intersection observer
        this.observer = new IntersectionObserver(
            (entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !this.loading && this.hasMore) {
                        this.loadMore();
                    }
                });
            },
            {
                root: null,
                rootMargin: `0px 0px ${this.options.threshold}px 0px`
            }
        );
        
        this.observer.observe(this.sentinel);
    }
    
    async loadMore() {
        this.loading = true;
        this.showLoader();
        
        try {
            // Simulate API call
            const items = await this.fetchItems(this.page, this.options.itemsPerPage);
            
            if (items.length === 0) {
                this.hasMore = false;
                this.hideLoader();
                return;
            }
            
            this.renderItems(items);
            this.page++;
            
        } catch (error) {
            console.error('Error loading items:', error);
            this.showError();
        } finally {
            this.loading = false;
            this.hideLoader();
        }
    }
    
    async fetchItems(page, limit) {
        // Simulate API delay
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Generate dummy data
        const items = [];
        const start = (page - 1) * limit + 1;
        
        for (let i = 0; i < limit; i++) {
            if (start + i <= 100) { // Limit to 100 items
                items.push({
                    id: start + i,
                    title: `Item ${start + i}`,
                    description: `Description for item ${start + i}`
                });
            }
        }
        
        return items;
    }
    
    renderItems(items) {
        const fragment = document.createDocumentFragment();
        
        items.forEach(item => {
            const card = document.createElement('div');
            card.className = 'item-card';
            card.style.cssText = `
                border: 1px solid #ddd;
                border-radius: 8px;
                padding: 16px;
                margin: 10px 0;
                background-color: white;
                transition: transform 0.2s;
            `;
            
            const title = document.createElement('h3');
            title.textContent = item.title;
            title.style.margin = '0 0 8px 0';
            
            const desc = document.createElement('p');
            desc.textContent = item.description;
            desc.style.margin = '0';
            desc.style.color = '#666';
            
            card.appendChild(title);
            card.appendChild(desc);
            
            // Hover effect
            card.addEventListener('mouseenter', () => {
                card.style.transform = 'translateX(5px)';
            });
            card.addEventListener('mouseleave', () => {
                card.style.transform = 'translateX(0)';
            });
            
            fragment.appendChild(card);
        });
        
        // Insert before sentinel
        this.container.insertBefore(fragment, this.sentinel);
    }
    
    showLoader() {
        if (!this.loader) {
            this.loader = document.createElement('div');
            this.loader.className = 'infinite-scroll-loader';
            this.loader.innerHTML = this.options.loadingHTML;
            this.loader.style.cssText = `
                text-align: center;
                padding: 20px;
                color: #666;
            `;
        }
        this.container.insertBefore(this.loader, this.sentinel);
    }
    
    hideLoader() {
        if (this.loader && this.loader.parentNode) {
            this.loader.parentNode.removeChild(this.loader);
        }
    }
    
    showError() {
        const error = document.createElement('div');
        error.className = 'error-message';
        error.textContent = 'Error loading items. Click to retry.';
        error.style.cssText = `
            text-align: center;
            padding: 20px;
            color: #dc3545;
            cursor: pointer;
        `;
        
        error.addEventListener('click', () => {
            error.remove();
            this.loadMore();
        });
        
        this.container.insertBefore(error, this.sentinel);
    }
    
    destroy() {
        if (this.observer) {
            this.observer.disconnect();
        }
        if (this.sentinel && this.sentinel.parentNode) {
            this.sentinel.parentNode.removeChild(this.sentinel);
        }
    }
}

// Usage
document.body.innerHTML = '&lt;div id="infinite-container"&gt;&lt;/div&gt;';
const infiniteScroll = new InfiniteScroll('infinite-container');</pre>
        <hr>

        <!-- PART 10: COMPREHENSIVE REFERENCE -->
        <h2>PART 10: COMPREHENSIVE REFERENCE</h2>
        <h3>10.1 Complete API Reference</h3>
        <pre>// Element Creation Methods
document.createElement(tagName);
document.createElementNS(namespaceURI, tagName);
document.createTextNode(text);
document.createComment(text);
document.createDocumentFragment();
document.createEvent(eventType); // Deprecated
document.createAttribute(attrName);

// Node Appending Methods
parentNode.appendChild(childNode);
parentNode.append(childNode1, childNode2, /* ... */);
parentNode.prepend(childNode1, childNode2, /* ... */);
parentNode.insertBefore(newNode, referenceNode);
parentNode.replaceChild(newChild, oldChild);

// Node Removal Methods
parentNode.removeChild(childNode);
childNode.remove();

// Cloning Methods
node.cloneNode(deep); // deep = true/false

// Element Properties
element.tagName
element.nodeName
element.nodeType
element.nodeValue
element.textContent
element.innerHTML
element.outerHTML
element.className
element.classList
element.id
element.style
element.dataset
element.attributes

// DOM Traversal Properties
element.parentNode
element.parentElement
element.childNodes
element.children
element.firstChild
element.firstElementChild
element.lastChild
element.lastElementChild
element.previousSibling
element.previousElementSibling
element.nextSibling
element.nextElementSibling</pre>

        <h3>10.2 Node Types Reference</h3>
        <pre>const nodeTypes = {
    1: 'ELEMENT_NODE',
    2: 'ATTRIBUTE_NODE', // Deprecated
    3: 'TEXT_NODE',
    4: 'CDATA_SECTION_NODE', // Deprecated
    5: 'ENTITY_REFERENCE_NODE', // Deprecated
    6: 'ENTITY_NODE', // Deprecated
    7: 'PROCESSING_INSTRUCTION_NODE',
    8: 'COMMENT_NODE',
    9: 'DOCUMENT_NODE',
    10: 'DOCUMENT_TYPE_NODE',
    11: 'DOCUMENT_FRAGMENT_NODE',
    12: 'NOTATION_NODE' // Deprecated
};

// Check node type
const element = document.createElement('div');
console.log(element.nodeType); // 1
console.log(nodeTypes[element.nodeType]); // 'ELEMENT_NODE'</pre>

        <h3>10.3 Quick Reference Card</h3>
        <table>
            <tr>
                <th>Task</th>
                <th>Method</th>
                <th>Example</th>
            </tr>
            <tr>
                <td>Create element</td>
                <td><code>createElement()</code></td>
                <td><code>document.createElement('div')</code></td>
            </tr>
            <tr>
                <td>Add at end</td>
                <td><code>appendChild()</code></td>
                <td><code>parent.appendChild(child)</code></td>
            </tr>
            <tr>
                <td>Add at beginning</td>
                <td><code>prepend()</code></td>
                <td><code>parent.prepend(child)</code></td>
            </tr>
            <tr>
                <td>Insert before</td>
                <td><code>insertBefore()</code></td>
                <td><code>parent.insertBefore(new, ref)</code></td>
            </tr>
            <tr>
                <td>Replace element</td>
                <td><code>replaceChild()</code></td>
                <td><code>parent.replaceChild(new, old)</code></td>
            </tr>
            <tr>
                <td>Remove element</td>
                <td><code>remove()</code></td>
                <td><code>element.remove()</code></td>
            </tr>
            <tr>
                <td>Remove child</td>
                <td><code>removeChild()</code></td>
                <td><code>parent.removeChild(child)</code></td>
            </tr>
            <tr>
                <td>Clone element</td>
                <td><code>cloneNode()</code></td>
                <td><code>element.cloneNode(true)</code></td>
            </tr>
            <tr>
                <td>Add text</td>
                <td><code>textContent</code></td>
                <td><code>el.textContent = 'text'</code></td>
            </tr>
            <tr>
                <td>Add HTML</td>
                <td><code>innerHTML</code></td>
                <td><code>el.innerHTML = '&lt;div&gt;'</code></td>
            </tr>
            <tr>
                <td>Add class</td>
                <td><code>classList.add()</code></td>
                <td><code>el.classList.add('class')</code></td>
            </tr>
            <tr>
                <td>Remove class</td>
                <td><code>classList.remove()</code></td>
                <td><code>el.classList.remove('class')</code></td>
            </tr>
            <tr>
                <td>Check class</td>
                <td><code>classList.contains()</code></td>
                <td><code>el.classList.contains('class')</code></td>
            </tr>
        </table>

        <hr>
        <h2>APPENDIX: PRACTICAL EXERCISES</h2>
        <p><strong>Exercise 1:</strong> Dynamic Form Builder â Create a function that generates a complete form based on
            a configuration object.</p>
        <p><strong>Exercise 2:</strong> Drag-and-Drop List â Implement a drag-and-drop list where items can be
            reordered.</p>
        <p><strong>Exercise 3:</strong> Notification System â Build a toast notification system that creates and removes
            notifications.</p>
        <p><strong>Exercise 4:</strong> Tab Component â Create a tabbed interface that dynamically creates and switches
            between content panels.</p>
        <p><strong>Exercise 5:</strong> Image Gallery with Lightbox â Build an image gallery where clicking an image
            creates a lightbox modal.</p>

        <hr>
        <p style="font-style: italic;">*This comprehensive guide covers everything from basic concepts to advanced
            implementations of creating and removing DOM elements. Practice each concept and refer back to specific
            sections as needed. The key to mastery is hands-on experimentation with all these techniques.*</p>

        <footer>
            Â· Creating and Removing DOM Elements Â· complete Â· no omissions
        </footer>
    </div>
</body>

</html>