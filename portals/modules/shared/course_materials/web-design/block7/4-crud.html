<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Notes · CRUD operations · full‑stack</title>
    <style>
        /* minimal, clean, readable — preserves all content exactly */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #f5f7fb;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            line-height: 1.6;
            color: #1e2b3c;
            padding: 2rem 1rem;
        }

        .document {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            border-radius: 28px;
            box-shadow: 0 20px 40px -20px rgba(0, 20, 40, 0.3);
            padding: 2.5rem 2rem;
        }

        h1,
        h2,
        h3,
        h4 {
            color: #0b2a41;
            margin-top: 2em;
            margin-bottom: 0.75em;
            font-weight: 600;
            letter-spacing: -0.01em;
        }

        h1 {
            font-size: 2.5rem;
            border-left: 8px solid #c4455f;
            padding-left: 1.2rem;
            margin-top: 0.5em;
        }

        h2 {
            font-size: 2rem;
            border-bottom: 2px solid #cfddee;
            padding-bottom: 0.3rem;
        }

        h3 {
            font-size: 1.6rem;
            color: #1f4870;
        }

        h4 {
            font-size: 1.3rem;
            color: #2b4d6e;
        }

        p,
        li,
        figcaption {
            margin: 1.2rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.8rem 0;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 20, 40, 0.08);
        }

        th {
            background: #1f3a5f;
            color: white;
            font-weight: 600;
            padding: 0.9rem;
        }

        td {
            padding: 0.8rem;
            border-bottom: 1px solid #d4e0ed;
            background: #fcfdff;
        }

        code,
        pre {
            background: #eaf0f8;
            border-radius: 14px;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
        }

        code {
            padding: 0.2rem 0.5rem;
            word-break: break-word;
        }

        pre {
            padding: 1.2rem 1.5rem;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            border: 1px solid #b7cee8;
            margin: 1.5rem 0;
        }

        hr {
            border: none;
            height: 2px;
            background: linear-gradient(90deg, #dbe5f2, white, #dbe5f2);
            margin: 2.5rem 0;
        }

        ul,
        ol {
            padding-left: 1.8rem;
            margin: 1rem 0;
        }

        li {
            margin: 0.5rem 0;
        }

        .badge-sub {
            background: #e0eaf5;
            color: #1e3c5c;
            font-weight: 500;
            padding: 0.2rem 1.2rem;
            border-radius: 40px;
            display: inline-block;
            margin: 0.8rem 0;
        }

        .diagram-ascii {
            background: #f1f7fe;
            padding: 1.5rem;
            border-radius: 24px;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
            border: 1px solid #b6cde5;
            line-height: 1.4;
        }

        /* preserve every line exactly as written, no omissions */
    </style>
</head>

<body>
    <div class="document">
        <!-- everything below is exactly the provided study notes, line by line, including all headings, tables, code blocks, and text. no extra markup. -->
        <h1>Study Notes: CRUD Operations in a Full-Stack App</h1>

        <h2>Connecting React Frontend to Backend/Mock Database</h2>

        <hr>

        <h2>1. Introduction to CRUD Operations</h2>

        <h3>What is CRUD?</h3>
        <p>CRUD is an acronym representing the four basic operations performed on persistent data in any application:
        </p>

        <table>
            <tr>
                <th>Operation</th>
                <th>HTTP Method</th>
                <th>Description</th>
                <th>SQL Equivalent</th>
            </tr>
            <tr>
                <td><strong>C</strong>reate</td>
                <td><code>POST</code></td>
                <td>Add new data/records</td>
                <td><code>INSERT</code></td>
            </tr>
            <tr>
                <td><strong>R</strong>ead</td>
                <td><code>GET</code></td>
                <td>Retrieve/fetch data</td>
                <td><code>SELECT</code></td>
            </tr>
            <tr>
                <td><strong>U</strong>pdate</td>
                <td><code>PUT</code> / <code>PATCH</code></td>
                <td>Modify existing data</td>
                <td><code>UPDATE</code></td>
            </tr>
            <tr>
                <td><strong>D</strong>elete</td>
                <td><code>DELETE</code></td>
                <td>Remove data</td>
                <td><code>DELETE</code></td>
            </tr>
        </table>

        <h3>Why CRUD Matters</h3>
        <ul>
            <li><strong>Foundation</strong> of all data-driven applications</li>
            <li><strong>Universal pattern</strong> across all programming languages</li>
            <li><strong>User interaction</strong> core (users constantly create, view, edit, and remove content)</li>
            <li><strong>Data persistence</strong> enables meaningful, stateful applications</li>
        </ul>

        <hr>

        <h2>2. Setting Up the Connection</h2>

        <h3>2.1 Understanding the Architecture</h3>
        <div class="diagram-ascii">
            ┌─────────────────┐ HTTP Requests ┌─────────────────┐
            │ │ ─────────────────────► │ │
            │ React Frontend │ (GET, POST, │ Backend API │
            │ (Client) │ PUT, DELETE) │ (Server) │
            │ │ ◀───────────────────── │ │
            └─────────────────┘ JSON Responses └────────┬────────┘
            │
            │ Database
            │ Queries
            ▼
            ┌─────────────────┐
            │ │
            │ Database │
            │ (SQL/NoSQL) │
            │ │
            └─────────────────┘
        </div>

        <h3>2.2 API Service Layer in React</h3>
        <p>Create a dedicated service file to handle all API calls:</p>
        <pre><code>// services/api.js
const API_BASE_URL = process.env.REACT_APP_API_URL || 'https://jsonplaceholder.typicode.com';

export const api = {
  // READ - Get all items
  getItems: async () => {
    const response = await fetch(`${API_BASE_URL}/items`);
    if (!response.ok) throw new Error('Failed to fetch items');
    return response.json();
  },
  
  // READ - Get single item by ID
  getItemById: async (id) => {
    const response = await fetch(`${API_BASE_URL}/items/${id}`);
    if (!response.ok) throw new Error('Item not found');
    return response.json();
  },
  
  // CREATE - Add new item
  createItem: async (itemData) => {
    const response = await fetch(`${API_BASE_URL}/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(itemData)
    });
    if (!response.ok) throw new Error('Failed to create item');
    return response.json();
  },
  
  // UPDATE - Modify existing item
  updateItem: async (id, itemData) => {
    const response = await fetch(`${API_BASE_URL}/items/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(itemData)
    });
    if (!response.ok) throw new Error('Failed to update item');
    return response.json();
  },
  
  // DELETE - Remove item
  deleteItem: async (id) => {
    const response = await fetch(`${API_BASE_URL}/items/${id}`, {
      method: 'DELETE'
    });
    if (!response.ok) throw new Error('Failed to delete item');
    return response.status === 204 ? null : response.json();
  }
};</code></pre>

        <hr>

        <h2>3. READ Operation: Displaying Data</h2>

        <h3>3.1 Fetching and Displaying Items</h3>
        <pre><code>// components/ItemList.jsx
import React, { useState, useEffect } from 'react';
import { api } from '../services/api';
import ItemCard from './ItemCard';

const ItemList = () => {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Fetch items when component mounts
  useEffect(() => {
    fetchItems();
  }, []);

  const fetchItems = async () => {
    try {
      setLoading(true);
      const data = await api.getItems();
      setItems(data);
      setError(null);
    } catch (err) {
      setError(err.message);
      console.error('Error fetching items:', err);
    } finally {
      setLoading(false);
    }
  };

  if (loading) return &lt;div className="loader"&gt;Loading items...&lt;/div&gt;;
  if (error) return &lt;div className="error"&gt;Error: {error}&lt;/div&gt;;

  return (
    &lt;div className="item-list"&gt;
      &lt;h2&gt;Items&lt;/h2&gt;
      {items.length === 0 ? (
        &lt;p&gt;No items found. Create your first item!&lt;/p&gt;
      ) : (
        items.map(item => (
          &lt;ItemCard 
            key={item.id} 
            item={item} 
            onDelete={fetchItems}  // Refresh list after delete
            onUpdate={fetchItems}   // Refresh list after update
          /&gt;
        ))
      )}
    &lt;/div&gt;
  );
};

export default ItemList;</code></pre>

        <h3>3.2 Displaying Individual Items</h3>
        <pre><code>// components/ItemCard.jsx
import React, { useState } from 'react';
import { api } from '../services/api';
import EditItemForm from './EditItemForm';

const ItemCard = ({ item, onDelete, onUpdate }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  const handleDelete = async () => {
    if (!window.confirm('Are you sure you want to delete this item?')) return;
    
    try {
      setIsDeleting(true);
      await api.deleteItem(item.id);
      onDelete(); // Trigger refresh in parent
    } catch (error) {
      console.error('Delete failed:', error);
      alert('Failed to delete item. Please try again.');
    } finally {
      setIsDeleting(false);
    }
  };

  if (isEditing) {
    return (
      &lt;EditItemForm 
        item={item} 
        onSave={() => {
          setIsEditing(false);
          onUpdate();
        }}
        onCancel={() => setIsEditing(false)}
      /&gt;
    );
  }

  return (
    &lt;div className="item-card"&gt;
      &lt;h3&gt;{item.title}&lt;/h3&gt;
      &lt;p&gt;{item.description}&lt;/p&gt;
      &lt;div className="item-actions"&gt;
        &lt;button 
          onClick={() => setIsEditing(true)}
          className="edit-btn"
        &gt;
          Edit
        &lt;/button&gt;
        &lt;button 
          onClick={handleDelete}
          disabled={isDeleting}
          className="delete-btn"
        &gt;
          {isDeleting ? 'Deleting...' : 'Delete'}
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default ItemCard;</code></pre>

        <hr>

        <h2>4. CREATE Operation: Adding New Data</h2>

        <h3>4.1 Create Form Component</h3>
        <pre><code>// components/CreateItemForm.jsx
import React, { useState } from 'react';
import { api } from '../services/api';

const CreateItemForm = ({ onItemCreated }) => {
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    category: 'general'
  });
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState({});

  // Handle input changes
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    // Clear error for this field when user types
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  // Validate form before submission
  const validateForm = () => {
    const newErrors = {};
    if (!formData.title.trim()) {
      newErrors.title = 'Title is required';
    }
    if (!formData.description.trim()) {
      newErrors.description = 'Description is required';
    }
    return newErrors;
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const validationErrors = validateForm();
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      setIsSubmitting(true);
      const newItem = await api.createItem(formData);
      
      // Reset form
      setFormData({ title: '', description: '', category: 'general' });
      
      // Notify parent component
      if (onItemCreated) {
        onItemCreated(newItem);
      }
      
      alert('Item created successfully!');
    } catch (error) {
      console.error('Create failed:', error);
      alert('Failed to create item. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit} className="create-form"&gt;
      &lt;h2&gt;Create New Item&lt;/h2&gt;
      
      &lt;div className="form-group"&gt;
        &lt;label htmlFor="title"&gt;Title *&lt;/label&gt;
        &lt;input
          type="text"
          id="title"
          name="title"
          value={formData.title}
          onChange={handleChange}
          className={errors.title ? 'error' : ''}
          disabled={isSubmitting}
        /&gt;
        {errors.title && &lt;span className="error-message"&gt;{errors.title}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="description"&gt;Description *&lt;/label&gt;
        &lt;textarea
          id="description"
          name="description"
          value={formData.description}
          onChange={handleChange}
          rows="4"
          className={errors.description ? 'error' : ''}
          disabled={isSubmitting}
        /&gt;
        {errors.description && &lt;span className="error-message"&gt;{errors.description}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="category"&gt;Category&lt;/label&gt;
        &lt;select
          id="category"
          name="category"
          value={formData.category}
          onChange={handleChange}
          disabled={isSubmitting}
        &gt;
          &lt;option value="general"&gt;General&lt;/option&gt;
          &lt;option value="work"&gt;Work&lt;/option&gt;
          &lt;option value="personal"&gt;Personal&lt;/option&gt;
          &lt;option value="other"&gt;Other&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;button 
        type="submit" 
        disabled={isSubmitting}
        className="submit-btn"
      &gt;
        {isSubmitting ? 'Creating...' : 'Create Item'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
};

export default CreateItemForm;</code></pre>

        <hr>

        <h2>5. UPDATE Operation: Modifying Existing Data</h2>

        <h3>5.1 Edit Form Component</h3>
        <pre><code>// components/EditItemForm.jsx
import React, { useState } from 'react';
import { api } from '../services/api';

const EditItemForm = ({ item, onSave, onCancel }) => {
  const [formData, setFormData] = useState({
    title: item.title || '',
    description: item.description || '',
    category: item.category || 'general'
  });
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const validateForm = () => {
    const newErrors = {};
    if (!formData.title.trim()) newErrors.title = 'Title is required';
    if (!formData.description.trim()) newErrors.description = 'Description is required';
    return newErrors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const validationErrors = validateForm();
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    try {
      setIsSubmitting(true);
      await api.updateItem(item.id, formData);
      onSave(); // Notify parent of successful update
    } catch (error) {
      console.error('Update failed:', error);
      alert('Failed to update item. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit} className="edit-form"&gt;
      &lt;h3&gt;Edit Item&lt;/h3&gt;
      
      &lt;div className="form-group"&gt;
        &lt;label htmlFor="edit-title"&gt;Title&lt;/label&gt;
        &lt;input
          type="text"
          id="edit-title"
          name="title"
          value={formData.title}
          onChange={handleChange}
          className={errors.title ? 'error' : ''}
          disabled={isSubmitting}
        /&gt;
        {errors.title && &lt;span className="error-message"&gt;{errors.title}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="edit-description"&gt;Description&lt;/label&gt;
        &lt;textarea
          id="edit-description"
          name="description"
          value={formData.description}
          onChange={handleChange}
          rows="3"
          className={errors.description ? 'error' : ''}
          disabled={isSubmitting}
        /&gt;
        {errors.description && &lt;span className="error-message"&gt;{errors.description}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="edit-category"&gt;Category&lt;/label&gt;
        &lt;select
          id="edit-category"
          name="category"
          value={formData.category}
          onChange={handleChange}
          disabled={isSubmitting}
        &gt;
          &lt;option value="general"&gt;General&lt;/option&gt;
          &lt;option value="work"&gt;Work&lt;/option&gt;
          &lt;option value="personal"&gt;Personal&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div className="form-actions"&gt;
        &lt;button 
          type="submit" 
          disabled={isSubmitting}
          className="save-btn"
        &gt;
          {isSubmitting ? 'Saving...' : 'Save Changes'}
        &lt;/button&gt;
        &lt;button 
          type="button" 
          onClick={onCancel}
          disabled={isSubmitting}
          className="cancel-btn"
        &gt;
          Cancel
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};

export default EditItemForm;</code></pre>

        <hr>

        <h2>6. DELETE Operation: Removing Data</h2>

        <h3>6.1 Delete with Confirmation</h3>
        <pre><code>// components/DeleteButton.jsx
import React, { useState } from 'react';
import { api } from '../services/api';

const DeleteButton = ({ itemId, onDeleteSuccess, children }) => {
  const [isDeleting, setIsDeleting] = useState(false);
  const [showConfirm, setShowConfirm] = useState(false);

  const handleDelete = async () => {
    try {
      setIsDeleting(true);
      await api.deleteItem(itemId);
      setShowConfirm(false);
      onDeleteSuccess();
    } catch (error) {
      console.error('Delete failed:', error);
      alert('Failed to delete item. Please try again.');
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    &lt;&gt;
      &lt;button 
        onClick={() => setShowConfirm(true)}
        className="delete-trigger"
        disabled={isDeleting}
      &gt;
        {children || 'Delete'}
      &lt;/button&gt;

      {showConfirm && (
        &lt;div className="delete-confirmation"&gt;
          &lt;p&gt;Are you sure you want to delete this item?&lt;/p&gt;
          &lt;p className="warning"&gt;This action cannot be undone.&lt;/p&gt;
          &lt;div className="confirmation-actions"&gt;
            &lt;button 
              onClick={handleDelete}
              disabled={isDeleting}
              className="confirm-delete"
            &gt;
              {isDeleting ? 'Deleting...' : 'Yes, Delete'}
            &lt;/button&gt;
            &lt;button 
              onClick={() => setShowConfirm(false)}
              disabled={isDeleting}
              className="cancel-delete"
            &gt;
              Cancel
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/&gt;
  );
};

export default DeleteButton;</code></pre>

        <hr>

        <h2>7. Complete Integration Example</h2>

        <h3>7.1 Main App Component</h3>
        <pre><code>// App.jsx
import React, { useState, useEffect } from 'react';
import { api } from './services/api';
import ItemList from './components/ItemList';
import CreateItemForm from './components/CreateItemForm';
import './App.css';

function App() {
  const [items, setItems] = useState([]);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // Fetch all items
  const fetchAllItems = async () => {
    try {
      const data = await api.getItems();
      setItems(data);
    } catch (error) {
      console.error('Failed to fetch items:', error);
    }
  };

  // Refresh items when trigger changes
  useEffect(() => {
    fetchAllItems();
  }, [refreshTrigger]);

  // Handle new item creation
  const handleItemCreated = (newItem) => {
    setItems(prev => [...prev, newItem]);
    setRefreshTrigger(prev => prev + 1);
  };

  // Handle item deletion
  const handleItemDeleted = () => {
    setRefreshTrigger(prev => prev + 1);
  };

  // Handle item update
  const handleItemUpdated = () => {
    setRefreshTrigger(prev => prev + 1);
  };

  return (
    &lt;div className="app"&gt;
      &lt;header&gt;
        &lt;h1&gt;CRUD Application Demo&lt;/h1&gt;
        &lt;p&gt;Total Items: {items.length}&lt;/p&gt;
      &lt;/header&gt;

      &lt;main&gt;
        &lt;section className="create-section"&gt;
          &lt;CreateItemForm onItemCreated={handleItemCreated} /&gt;
        &lt;/section&gt;

        &lt;section className="items-section"&gt;
          &lt;ItemList 
            items={items}
            onDelete={handleItemDeleted}
            onUpdate={handleItemUpdated}
          /&gt;
        &lt;/section&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre>

        <hr>

        <h2>8. Using a Mock Database (JSON Server)</h2>

        <h3>8.1 Setting Up JSON Server for Development</h3>
        <pre><code># Install JSON Server globally
npm install -g json-server

# Create a db.json file</code></pre>

        <pre><code>// db.json
{
  "items": [
    {
      "id": 1,
      "title": "Learn React",
      "description": "Complete the React tutorial",
      "category": "work",
      "completed": false,
      "createdAt": "2024-01-15T10:00:00Z"
    },
    {
      "id": 2,
      "title": "Build a CRUD app",
      "description": "Practice full-stack development",
      "category": "personal",
      "completed": false,
      "createdAt": "2024-01-16T14:30:00Z"
    }
  ]
}</code></pre>

        <pre><code># Run JSON Server (port 3001 to avoid conflict with React)
json-server --watch db.json --port 3001</code></pre>

        <h3>8.2 Updated API Service for JSON Server</h3>
        <pre><code>// services/mockApi.js
const API_BASE_URL = 'http://localhost:3001';

export const mockApi = {
  // GET all items with optional filtering
  getItems: async (filters = {}) => {
    const queryParams = new URLSearchParams(filters).toString();
    const url = `${API_BASE_URL}/items${queryParams ? `?${queryParams}` : ''}`;
    
    const response = await fetch(url);
    return response.json();
  },

  // GET single item
  getItem: async (id) => {
    const response = await fetch(`${API_BASE_URL}/items/${id}`);
    return response.json();
  },

  // POST new item (id is auto-generated)
  createItem: async (itemData) => {
    const newItem = {
      ...itemData,
      id: Date.now(), // Simple ID generation for mock
      createdAt: new Date().toISOString()
    };

    const response = await fetch(`${API_BASE_URL}/items`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(newItem)
    });
    return response.json();
  },

  // PUT update item
  updateItem: async (id, itemData) => {
    const response = await fetch(`${API_BASE_URL}/items/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(itemData)
    });
    return response.json();
  },

  // DELETE item
  deleteItem: async (id) => {
    await fetch(`${API_BASE_URL}/items/${id}`, {
      method: 'DELETE'
    });
    return id; // Return the deleted item's ID
  }
};</code></pre>

        <hr>

        <h2>9. Error Handling and Loading States</h2>

        <h3>9.1 Custom Hook for Data Operations</h3>
        <pre><code>// hooks/useCrudOperations.js
import { useState, useCallback } from 'react';
import { api } from '../services/api';

export const useCrudOperations = (resourceName = 'items') => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // READ operation
  const fetchAll = useCallback(async (params = {}) => {
    setLoading(true);
    setError(null);
    try {
      const result = await api.getItems(params);
      setData(result);
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // CREATE operation
  const create = useCallback(async (newItem) => {
    setLoading(true);
    setError(null);
    try {
      const result = await api.createItem(newItem);
      setData(prev => [...prev, result]);
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // UPDATE operation
  const update = useCallback(async (id, updatedData) => {
    setLoading(true);
    setError(null);
    try {
      const result = await api.updateItem(id, updatedData);
      setData(prev => prev.map(item => 
        item.id === id ? result : item
      ));
      return result;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // DELETE operation
  const remove = useCallback(async (id) => {
    setLoading(true);
    setError(null);
    try {
      await api.deleteItem(id);
      setData(prev => prev.filter(item => item.id !== id));
      return id;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    data,
    loading,
    error,
    fetchAll,
    create,
    update,
    remove
  };
};</code></pre>

        <hr>

        <h2>10. Best Practices Summary</h2>

        <h3>✅ DO's:</h3>
        <ul>
            <li><strong>Separate concerns</strong>: Keep API logic in service files</li>
            <li><strong>Handle loading states</strong>: Show spinners/skeletons during async operations</li>
            <li><strong>Validate data</strong>: Client-side validation before sending to server</li>
            <li><strong>Handle errors gracefully</strong>: User-friendly error messages</li>
            <li><strong>Use optimistic updates</strong>: Update UI immediately, revert on error</li>
            <li><strong>Confirm destructive actions</strong>: Always ask before deleting</li>
            <li><strong>Keep components small</strong>: Single responsibility principle</li>
            <li><strong>Use environment variables</strong>: Store API URLs in <code>.env</code> files</li>
        </ul>

        <h3>❌ DON'Ts:</h3>
        <ul>
            <li>Don't hardcode API URLs in components</li>
            <li>Don't forget to handle error cases</li>
            <li>Don't ignore cleanup in <code>useEffect</code></li>
            <li>Don't mutate state directly</li>
            <li>Don't expose sensitive data in frontend code</li>
            <li>Don't skip input validation</li>
        </ul>

        <hr>

        <h2>Summary: CRUD Flow Diagram</h2>
        <div class="diagram-ascii">
            ┌─────────────────────────────────────────────────────────────┐
            │ USER INTERACTION │
            └─────────────────────────────────────────────────────────────┘
            │
            ▼
            ┌─────────────────────────────────────────────────────────────┐
            │ REACT COMPONENTS │
            │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ │
            │ │ Form │ │ List │ │ Card │ │ Button │ │
            │ └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘ │
            └───────┼──────────────┼──────────────┼──────────────┼─────────┘
            │ │ │ │
            ▼ ▼ ▼ ▼
            ┌─────────────────────────────────────────────────────────────┐
            │ API SERVICE LAYER │
            │ ┌──────────────────────────────────────────────────────┐ │
            │ │ createItem() getItems() updateItem() deleteItem() │ │
            │ └──────────────────────────────────────────────────────┘ │
            └───────────────────────────────┬─────────────────────────────┘
            │
            ▼
            ┌───────────────────────┐
            │ HTTP REQUESTS │
            │ POST/GET/PUT/DELETE │
            └───────────┬───────────┘
            │
            ▼
            ┌───────────────────────┐
            │ BACKEND API / │
            │ MOCK DATABASE │
            │ (JSON Server) │
            └───────────────────────┘
        </div>

        <p>This foundation of CRUD operations is essential for building any data-driven application. Once mastered, you
            can apply these patterns to any framework or backend technology.</p>
        <!-- end of study notes -->
    </div>
</body>

</html>