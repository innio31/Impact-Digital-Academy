<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teaching note · React + backend (simplified)</title>
    <style>
        /* clean, readable study‑note style — exactly matches source content */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
            background: #f2f5f9;
            color: #1e2b3c;
            line-height: 1.55;
            padding: 2rem 1rem;
        }

        .note-container {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            border-radius: 2rem;
            box-shadow: 0 20px 40px -20px #1f3a5f;
            padding: 2rem 2rem 2.5rem;
        }

        h1 {
            font-size: 2.6rem;
            font-weight: 700;
            background: linear-gradient(145deg, #1d3b5c, #b13e5c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 0.5rem;
            border-left: 12px solid #b13e5c;
            padding-left: 1.5rem;
        }

        h2 {
            font-size: 2rem;
            margin: 2rem 0 1rem;
            color: #1f3a5f;
            border-bottom: 3px solid #cf6f89;
            padding-bottom: 0.4rem;
        }

        h3 {
            font-size: 1.7rem;
            margin: 1.8rem 0 1rem;
            color: #1f3a5f;
        }

        h4 {
            font-size: 1.3rem;
            margin: 1.5rem 0 0.5rem;
            color: #1e3c5c;
        }

        p,
        li,
        .block {
            font-size: 1.05rem;
            color: #1e2f40;
        }

        .overview,
        .learning-objectives,
        .prereqs,
        .key-concepts,
        .comparison,
        .pitfalls,
        .activities,
        .assessment,
        .cheat-sheet {
            margin: 2rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: #f6faff;
            border-radius: 1.4rem;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(28, 45, 75, 0.1);
            margin: 1.5rem 0;
        }

        th {
            background: #2b4d6e;
            color: white;
            font-weight: 600;
            padding: 0.9rem 0.8rem;
            font-size: 1rem;
        }

        td {
            padding: 0.9rem 0.8rem;
            border-bottom: 1px solid #c9d8ec;
            background: #fdfeff;
        }

        code,
        pre {
            background: #eef4fc;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            border-radius: 12px;
        }

        code {
            padding: 0.2rem 0.4rem;
            font-size: 0.95em;
            color: #1e3c5c;
        }

        pre {
            padding: 1.2rem;
            overflow-x: auto;
            border: 1px solid #bacde0;
            margin: 1.2rem 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .tip-box {
            background: #e2ecfb;
            border-left: 8px solid #38658f;
            padding: 1.4rem;
            border-radius: 1.8rem;
            margin: 1.8rem 0;
        }

        .badge {
            background: #1f3a5f;
            color: white;
            font-size: 0.8rem;
            padding: 0.2rem 1.2rem;
            border-radius: 40px;
            display: inline-block;
            margin-right: 0.6rem;
        }

        hr {
            border: none;
            height: 3px;
            background: linear-gradient(to right, #dbe3f0, #fcfdff, #dbe3f0);
            margin: 2rem 0;
        }

        .footer-note {
            text-align: center;
            margin-top: 2.5rem;
            color: #2b4d6e;
        }

        ul,
        ol {
            padding-left: 1.8rem;
            margin: 1rem 0;
        }

        li {
            margin: 0.3rem 0;
        }

        blockquote {
            background: #f1f5fc;
            border-radius: 1.6rem;
            padding: 1.2rem 1.8rem;
            font-style: italic;
            border: 1px solid #b8cee8;
            color: #1f3d63;
        }
    </style>
</head>

<body>
    <div class="note-container">
        <!-- Title exactly as given -->
        <h1>Teaching Note: Connecting React to a Backend (Simplified)</h1>

        <!-- Overview section (preserve every line) -->
        <section class="overview">
            <h2>Overview</h2>
            <p>This note provides educators with a structured approach to teaching students how to connect React
                applications to backend services. The focus is on simplification - introducing concepts without
                overwhelming students with complex server setup. Two approaches are covered: using
                <code>localStorage</code> as a mock database and introducing Firebase as a Backend-as-a-Service (BaaS)
                solution.</p>
        </section>

        <hr>

        <!-- Learning objectives (exact) -->
        <section class="learning-objectives">
            <h2>Learning Objectives</h2>
            <p>By the end of this lesson, students will be able to:</p>
            <ul>
                <li>Explain the need for connecting frontend applications to backend services</li>
                <li>Use <code>localStorage</code> to persist data in the browser for prototyping</li>
                <li>Understand what a BaaS is and why Firebase simplifies backend development</li>
                <li>Make API calls from React components using the <code>fetch</code> function</li>
                <li>Use the <code>useEffect</code> hook to fetch data when components load</li>
                <li>Handle loading and error states during data fetching</li>
            </ul>
        </section>

        <hr>

        <!-- Prerequisites -->
        <section class="prereqs">
            <h2>Prerequisites</h2>
            <p>Students should already understand:</p>
            <ul>
                <li>React components, props, and state (<code>useState</code>)</li>
                <li>Basic JavaScript asynchronous operations (Promises)</li>
                <li>JSX and event handling in React</li>
            </ul>
        </section>

        <hr>

        <!-- Key concepts to cover (preserve subsections, tables, code) -->
        <section class="key-concepts">
            <h2>Key Concepts to Cover</h2>

            <!-- 1. Why need backend -->
            <h3>1. Why Do We Need a Backend?</h3>
            <div class="tip-box">
                <span class="badge">Teaching Tip</span> Start with a simple question: <em>"What happens to your to-do
                    list when you refresh the page?"</em>
            </div>
            <p><strong>Discussion Points:</strong></p>
            <ul>
                <li>Current React apps lose all data on refresh (state is temporary)</li>
                <li>Real applications need data persistence</li>
                <li>Data needs to be shared across devices and users</li>
                <li>The backend handles:
                    <ul>
                        <li>Storing data in databases</li>
                        <li>User authentication</li>
                        <li>Business logic</li>
                        <li>Serving data to the frontend</li>
                    </ul>
                </li>
            </ul>
            <p><strong>Analogy:</strong> Think of the frontend as a restaurant menu (display) and the backend as the
                kitchen (preparation) and refrigerator (storage).</p>

            <!-- 2. Approach 1 localStorage -->
            <h3>2. Approach 1: Mocking with localStorage</h3>
            <div class="tip-box">
                <span class="badge">Teaching Tip</span> Present this as a "training wheels" approach before introducing
                real APIs.
            </div>
            <p><strong>What is localStorage?</strong></p>
            <ul>
                <li>Built into all modern browsers</li>
                <li>Allows storing data as key-value pairs</li>
                <li>Data persists even after page refresh</li>
                <li>Maximum storage: ~5-10MB per domain</li>
                <li>Data is stored locally on the user's device</li>
            </ul>
            <p><strong>Basic localStorage Methods:</strong></p>
            <pre><code>// Save data
localStorage.setItem('username', 'john_doe');

// Retrieve data
const user = localStorage.getItem('username');

// Remove data
localStorage.removeItem('username');

// Clear all data
localStorage.clear();

// Working with objects (must stringify)
const user = { name: 'John', age: 30 };
localStorage.setItem('user', JSON.stringify(user));

// Retrieving objects (must parse)
const savedUser = JSON.parse(localStorage.getItem('user'));</code></pre>

            <p><strong>Practical Example: Todo App with localStorage</strong></p>
            <pre><code>import React, { useState, useEffect } from 'react';

function TodoApp() {
  // Initialize state from localStorage or empty array
  const [todos, setTodos] = useState(() => {
    const savedTodos = localStorage.getItem('todos');
    return savedTodos ? JSON.parse(savedTodos) : [];
  });
  const [inputValue, setInputValue] = useState('');

  // Save to localStorage whenever todos change
  useEffect(() => {
    localStorage.setItem('todos', JSON.stringify(todos));
  }, [todos]);

  const addTodo = () => {
    if (inputValue.trim()) {
      const newTodo = {
        id: Date.now(),
        text: inputValue,
        completed: false
      };
      setTodos([...todos, newTodo]);
      setInputValue('');
    }
  };

  return (
    &lt;div&gt;
      &lt;h2&gt;My Todo List&lt;/h2&gt;
      &lt;input
        value={inputValue}
        onChange={(e) =&gt; setInputValue(e.target.value)}
        placeholder="Add a todo"
      /&gt;
      &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
      
      &lt;ul&gt;
        {todos.map(todo =&gt; (
          &lt;li key={todo.id}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() =&gt; {
                const updatedTodos = todos.map(t =&gt;
                  t.id === todo.id ? {...t, completed: !t.completed} : t
                );
                setTodos(updatedTodos);
              }}
            /&gt;
            &lt;span style={{textDecoration: todo.completed ? 'line-through' : 'none'}}&gt;
              {todo.text}
            &lt;/span&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

export default TodoApp;</code></pre>

            <p><strong>Key Teaching Points:</strong></p>
            <ul>
                <li>The <code>useState</code> lazy initializer function prevents parsing on every render</li>
                <li>The <code>useEffect</code> hook saves data whenever <code>todos</code> change</li>
                <li>Data survives page refreshes!</li>
            </ul>
            <p><strong>Limitations to Discuss:</strong></p>
            <ul>
                <li>Data is device-specific (won't sync across devices)</li>
                <li>Limited storage space</li>
                <li>Not secure for sensitive data</li>
                <li>User can clear it easily</li>
            </ul>

            <!-- 3. Introduction to BaaS -->
            <h3>3. Approach 2: Introduction to Backend-as-a-Service (BaaS)</h3>
            <div class="tip-box">
                <span class="badge">Teaching Tip</span> Frame BaaS as "backend for busy frontend developers."
            </div>
            <p><strong>What is BaaS?</strong><br> A cloud service model where backend infrastructure is fully managed,
                allowing developers to focus on frontend code.</p>
            <p><strong>Popular BaaS Options:</strong></p>
            <table>
                <thead>
                    <tr>
                        <th>Service</th>
                        <th>Best For</th>
                        <th>Key Features</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Firebase</strong></td>
                        <td>Beginners, real-time apps</td>
                        <td>Authentication, Firestore DB, Hosting, Storage</td>
                    </tr>
                    <tr>
                        <td><strong>Supabase</strong></td>
                        <td>SQL lovers</td>
                        <td>PostgreSQL, Auth, Storage, Real-time</td>
                    </tr>
                    <tr>
                        <td><strong>Appwrite</strong></td>
                        <td>Open-source fans</td>
                        <td>Self-hosted option, Auth, Database</td>
                    </tr>
                    <tr>
                        <td><strong>Backendless</strong></td>
                        <td>Visual builders</td>
                        <td>GUI console, Codeless logic</td>
                    </tr>
                </tbody>
            </table>
            <p><strong>Why Firebase for Teaching?</strong></p>
            <ul>
                <li>Generous free tier</li>
                <li>Excellent documentation</li>
                <li>Real-time capabilities</li>
                <li>Simple JavaScript SDK</li>
                <li>Google-backed (perceived reliability)</li>
            </ul>
            <p><strong>Setting Up Firebase (Quick Demo):</strong></p>
            <ol>
                <li>Go to <a href="#">firebase.google.com</a> (link placeholder)</li>
                <li>Click "Get started" and create a project</li>
                <li>Register a web app (&lt;/&gt; icon)</li>
                <li>Copy the configuration object</li>
                <li>Enable Firestore Database in test mode</li>
            </ol>
            <p><strong>Installing Firebase:</strong></p>
            <pre><code>npm install firebase</code></pre>
            <p><strong>Firebase Configuration:</strong></p>
            <pre><code>// firebase.js
import { initializeApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';

const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_AUTH_DOMAIN",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_STORAGE_BUCKET",
  messagingSenderId: "YOUR_SENDER_ID",
  appId: "YOUR_APP_ID"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
export const db = getFirestore(app);</code></pre>

            <!-- 4. Making API calls with fetch in useEffect -->
            <h3>4. Making API Calls with Fetch in useEffect</h3>
            <div class="tip-box">
                <span class="badge">Teaching Tip</span> This is the bridge between the mock (localStorage) and real
                backend (Firebase).
            </div>
            <p><strong>The Fetch API Basics:</strong></p>
            <pre><code>// GET request
fetch('https://api.example.com/todos')
  .then(response =&gt; response.json())
  .then(data =&gt; console.log(data))
  .catch(error =&gt; console.error('Error:', error));

// POST request
fetch('https://api.example.com/todos', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    title: 'New Todo',
    completed: false
  })
})
  .then(response =&gt; response.json())
  .then(data =&gt; console.log(data));</code></pre>

            <p><strong>Using Fetch with useEffect:</strong></p>
            <pre><code>import React, { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    // Define the fetch function inside useEffect
    const fetchUsers = async () =&gt; {
      try {
        setLoading(true);
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        setUsers(data);
        setError(null);
      } catch (err) {
        setError(err.message);
        console.error('Fetch error:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []); // Empty dependency array = run once on mount

  // Loading state
  if (loading) return &lt;div&gt;Loading users...&lt;/div&gt;;
  
  // Error state
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;

  // Success state
  return (
    &lt;div&gt;
      &lt;h2&gt;User List&lt;/h2&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;
            {user.name} - {user.email}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

export default UserList;</code></pre>

            <p><strong>Key Teaching Points:</strong></p>
            <ol>
                <li><strong>Empty dependency array</strong> (<code>[]</code>) means the effect runs once after initial
                    render</li>
                <li><strong>Async/await</strong> makes asynchronous code read like synchronous code</li>
                <li><strong>Loading state</strong> provides better user experience</li>
                <li><strong>Error handling</strong> is crucial for production apps</li>
                <li><strong>Cleanup</strong> (not shown) is needed for preventing memory leaks</li>
            </ol>

            <!-- 5. Putting it together: Firebase + React -->
            <h3>5. Putting It Together: Firebase + React</h3>
            <p><strong>Adding Data to Firestore:</strong></p>
            <pre><code>import React, { useState } from 'react';
import { db } from './firebase';
import { collection, addDoc } from 'firebase/firestore';

function AddTodo() {
  const [text, setText] = useState('');

  const handleSubmit = async (e) =&gt; {
    e.preventDefault();
    
    try {
      // Add a new document to the "todos" collection
      const docRef = await addDoc(collection(db, 'todos'), {
        text: text,
        completed: false,
        createdAt: new Date()
      });
      
      console.log('Todo added with ID:', docRef.id);
      setText(''); // Clear input
      
    } catch (error) {
      console.error('Error adding todo:', error);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        value={text}
        onChange={(e) =&gt; setText(e.target.value)}
        placeholder="Enter todo"
        required
      /&gt;
      &lt;button type="submit"&gt;Add Todo&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

            <p><strong>Reading Data from Firestore in Real-Time:</strong></p>
            <pre><code>import React, { useState, useEffect } from 'react';
import { db } from './firebase';
import { collection, onSnapshot } from 'firebase/firestore';

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    // Create a real-time listener
    const unsubscribe = onSnapshot(
      collection(db, 'todos'),
      (snapshot) =&gt; {
        const todosData = snapshot.docs.map(doc =&gt; ({
          id: doc.id,
          ...doc.data()
        }));
        setTodos(todosData);
        setLoading(false);
      },
      (error) =&gt; {
        console.error('Error fetching todos:', error);
        setLoading(false);
      }
    );

    // Cleanup subscription on unmount
    return () =&gt; unsubscribe();
  }, []);

  if (loading) return &lt;div&gt;Loading todos...&lt;/div&gt;;

  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={todo.id}&gt;
          &lt;input 
            type="checkbox" 
            checked={todo.completed} 
            readOnly 
          /&gt;
          {todo.text}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

            <p><strong>Key Teaching Points:</strong></p>
            <ul>
                <li><code>onSnapshot</code> creates a real-time connection (updates automatically!)</li>
                <li>The cleanup function (<code>return () =&gt; unsubscribe()</code>) prevents memory leaks</li>
                <li>Firestore documents need to be mapped to include their <code>id</code></li>
            </ul>

            <!-- 6. Comparison table -->
            <h3>6. Comparison: localStorage vs. Firebase</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>localStorage</th>
                        <th>Firebase</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Persistence</strong></td>
                        <td>Browser only</td>
                        <td>Cloud-based</td>
                    </tr>
                    <tr>
                        <td><strong>Data Sharing</strong></td>
                        <td>Current device only</td>
                        <td>Any device with login</td>
                    </tr>
                    <tr>
                        <td><strong>Real-time</strong></td>
                        <td>No</td>
                        <td>Yes (with listeners)</td>
                    </tr>
                    <tr>
                        <td><strong>Setup Complexity</strong></td>
                        <td>None (built-in)</td>
                        <td>Moderate (requires account)</td>
                    </tr>
                    <tr>
                        <td><strong>Storage Limit</strong></td>
                        <td>~5-10MB</td>
                        <td>1GB free (Firestore)</td>
                    </tr>
                    <tr>
                        <td><strong>Security</strong></td>
                        <td>No security</td>
                        <td>Rules-based security</td>
                    </tr>
                    <tr>
                        <td><strong>Offline Support</strong></td>
                        <td>Yes</td>
                        <td>Yes (with SDK)</td>
                    </tr>
                    <tr>
                        <td><strong>Authentication</strong></td>
                        <td>Manual implementation</td>
                        <td>Built-in</td>
                    </tr>
                </tbody>
            </table>
            <blockquote>
                <p><strong>Teaching Script:</strong> "Think of localStorage as a sticky note on your monitor - quick
                    notes that only you can see on that computer. Firebase is like a shared whiteboard in a cloud -
                    anyone with permission can see and update it from anywhere, in real-time."</p>
            </blockquote>
        </section>

        <hr>

        <!-- Common pitfalls -->
        <section class="pitfalls">
            <h2>Common Pitfalls &amp; Teaching Solutions</h2>
            <h4>Pitfall 1: Forgetting the Dependency Array</h4>
            <pre><code>// BAD - runs on every render
useEffect(() => {
  fetchData();
});

// GOOD - runs once on mount
useEffect(() => {
  fetchData();
}, []);</code></pre>
            <h4>Pitfall 2: Not Handling Loading States</h4>
            <pre><code>// BAD - flashes empty state then data
const [data, setData] = useState([]);
// ...fetch data, setData...

// GOOD - shows loading indicator
const [loading, setLoading] = useState(true);
// ...setLoading(false) when done...
if (loading) return &lt;Spinner /&gt;;</code></pre>
            <h4>Pitfall 3: Missing Error Handling</h4>
            <pre><code>// BAD - silent failure
const data = await fetch(url);

// GOOD - handle errors
try {
  const response = await fetch(url);
  if (!response.ok) throw new Error('Network error');
  const data = await response.json();
} catch (error) {
  setError(error.message);
}</code></pre>
            <h4>Pitfall 4: Memory Leaks with Async Operations</h4>
            <pre><code>// BAD - may set state on unmounted component
useEffect(() => {
  fetchData().then(setData);
}, []);

// GOOD - track mounted state
useEffect(() => {
  let isMounted = true;
  fetchData().then(data => {
    if (isMounted) setData(data);
  });
  return () => { isMounted = false; };
}, []);</code></pre>
        </section>

        <hr>

        <!-- Classroom activities (exact) -->
        <section class="activities">
            <h2>Classroom Activities</h2>
            <h4>Activity 1: localStorage Todo (45 minutes)</h4>
            <p>Have students build a todo app that persists with localStorage. They should:</p>
            <ol>
                <li>Initialize state from localStorage</li>
                <li>Save to localStorage on every update</li>
                <li>Add ability to delete items</li>
                <li>Test that data survives refresh</li>
            </ol>
            <h4>Activity 2: Fetch from Public API (45 minutes)</h4>
            <p>Students fetch data from a public API (JSONPlaceholder) and display it:</p>
            <ol>
                <li>Create loading and error states</li>
                <li>Fetch posts or users on component mount</li>
                <li>Display data in a styled list</li>
                <li>Add a refresh button that fetches again</li>
            </ol>
            <h4>Activity 3: Firebase Integration (60 minutes)</h4>
            <p>Guide students through:</p>
            <ol>
                <li>Creating a Firebase project</li>
                <li>Adding Firebase to their React app</li>
                <li>Setting up Firestore in test mode</li>
                <li>Building a real-time message board</li>
            </ol>
        </section>

        <hr>

        <!-- Assessment questions (preserve every line) -->
        <section class="assessment">
            <h2>Assessment Questions</h2>
            <h4>Multiple Choice</h4>
            <ol>
                <li><strong>Which hook is primarily used for data fetching in React?</strong><br>
                    a) useState<br>
                    b) useEffect ✓<br>
                    c) useReducer<br>
                    d) useCallback</li>
                <li><strong>What does the empty dependency array <code>[]</code> in useEffect signify?</strong><br>
                    a) The effect runs on every render<br>
                    b) The effect runs only once after the initial render ✓<br>
                    c) The effect never runs<br>
                    d) The effect runs only when state changes</li>
                <li><strong>Why should you stringify data before storing in localStorage?</strong><br>
                    a) To compress the data<br>
                    b) Because localStorage only stores strings ✓<br>
                    c) For security purposes<br>
                    d) It's optional, not required</li>
            </ol>
            <h4>Code Review Question</h4>
            <p>Identify the issues in this code:</p>
            <pre><code>useEffect(() => {
  fetch('https://api.example.com/data')
    .then(data => setData(data));
}, [data]);</code></pre>
            <p><strong>Issues:</strong></p>
            <ol>
                <li>Missing <code>.json()</code> call to parse response</li>
                <li>No error handling</li>
                <li>Dependency on <code>data</code> creates infinite loop</li>
                <li>Missing loading state</li>
            </ol>
        </section>

        <hr>

        <!-- Extension topics -->
        <section>
            <h2>Extension Topics (For Advanced Students)</h2>
            <ol>
                <li><strong>React Query / TanStack Query</strong> - Advanced data fetching library</li>
                <li><strong>Axios</strong> - Alternative to fetch with more features</li>
                <li><strong>SWR</strong> - Stale-while-revalidate pattern</li>
                <li><strong>GraphQL</strong> - Alternative to REST APIs</li>
                <li><strong>Firebase Security Rules</strong> - Protecting data</li>
                <li><strong>Pagination</strong> - Loading data in chunks</li>
                <li><strong>Optimistic Updates</strong> - Update UI before API confirms</li>
            </ol>
        </section>

        <hr>

        <!-- Summary cheat sheet -->
        <section class="cheat-sheet">
            <h2>Summary Cheat Sheet for Students</h2>
            <pre><code>// localStorage
localStorage.setItem('key', JSON.stringify(value));
const value = JSON.parse(localStorage.getItem('key'));

// Basic fetch in useEffect
useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    try {
      const res = await fetch(url);
      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };
  fetchData();
}, []);

// Loading/error states
if (loading) return &lt;Loading /&gt;;
if (error) return &lt;Error message={error} /&gt;;
return &lt;Display data={data} /&gt;;</code></pre>
        </section>

        <hr>

        <!-- Recommended resources -->
        <section>
            <h2>Recommended Resources</h2>
            <ul>
                <li><a href="#">React Official Docs: useEffect</a> (https://react.dev/reference/react/useEffect)</li>
                <li><a href="#">MDN: Fetch API</a> (https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)</li>
                <li><a href="#">Firebase Documentation</a> (https://firebase.google.com/docs)</li>
                <li><a href="#">JSONPlaceholder - Fake API for Testing</a> (https://jsonplaceholder.typicode.com)</li>
            </ul>
        </section>

        <div class="footer-note">
            ⚡ full teaching note – every line preserved from source
        </div>
    </div>
</body>

</html>